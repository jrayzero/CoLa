from block import Block,View

@dataclass(init=False)
class FlagTree[E,T,C,F]:
  """
  Set of flags corresponding to a partition defined by an AndPTree. See AndPTree for
  the to_flagtree function. This is extremely similar to the structure of AndPTree.
  You can incrementally build up the tree too. This does not check that your partitions
  don't overlap and what not because that would be expensive. 

  There are several ways to access a FlagTree. See __getitem__, __setitem__, leaf_match, any_match.
  

  F = type of flag value
  """

  value: View[E,T,C]
  children: list[FlagTree[E,T,C,F]]
  flag: F # all nodes get this, even if they aren't leaves

  def __init__(self, flag: F, value: View[E,T,C]):
    self.value = value
    self.flag = flag
    self.children = []

  def __init__(self, flag: F, value: Block[E,T,C]):
    self.value = View(value)
    self.flag = flag
    self.children = []

  def __init__(self, value: View[E,T,C]):
    self.value = value
    self.children = []
    self.flag = F()

  def __init__(self, value: Block[E,T,C]):
    self.value = View(value)
    self.children = []
    self.flag = F()

  def add_child(self, child: FlagTree[E,T,C,F]):
    self.children.append(child)

  # TODO support reading/writing from multiple flags values if obj spans over multiple nodes
  # TODO if I had a separate getitem wrapper, I wouldn't have to check containment in the base case
  # each time (cause other than the first iteration, the base case is only reached IF obj is fully contained
  # in self.) Same goes for setitem

  def _getitem(self, obj):
    if len(self.children) == 0:
      return self.flag
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._getitem(obj)
      # didn't find a node
      return None    

  def __getitem__(self, obj: View[E,T,C]) -> Optional[F]:
    """
    Get flag value out of the leaf that completely encapsluates obj (or return None).
    """
    if len(self.children) == 0:
      if obj.base.fully_contained(self.value.base):
        return self.flag
      else:
        return None
    else:
      return self._getitem(obj)

  def _setitem(self, obj, flag):
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child[obj] = flag
          found = True
          break
      assert found

  def __setitem__(self, obj: View[E,T,C], flag: F):
    """
    Set flag value out for the leaf that completely encapsluates obj (or fail)
    """    
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._setitem(obj, flag)
          found = True
          break
      assert found

  def _leaf_match(self, obj, flag):
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
      return
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._leaf_match(obj, flag)
          return
      assert False # doesn't have a location at all in this stre

  def leaf_match(self, obj: View[E,T,C], flag: F):
    """
    See if obj has a leaf node that exactly matches it. If yes,
    set the flag. Otherwise, add in the node in the appropriate location
    and set the flag.
    """
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
      return
    else:
      self._leaf_match(obj, flag)

  def _leaf_match(self, obj) -> Optional[F]:
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        return None
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._leaf_match(obj)
      return None

  def leaf_match(self, obj: View[E,T,C]) -> Optional[F]:
    """
    See if obj has a leaf node that exactly matches it. If yes,
    get the flag.
    """ 
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        return None
    else:
      return self._leaf_match(obj)

  def _any_match(self, obj, flag):
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
      return
    else:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
        return
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._any_match(obj, flag)
          return
      # if reached here, then we can't go down another level, so we add ourself here    
      ft = FlagTree(flag, obj)
      self.add_child(ft)

  def any_match(self, obj: View[E,T,C], flag: F):
    """
    See if view has a leaf node that exactly matches it. If yes,
    set the flag. Otherwise, add in the node in the appropriate location
    and set the flag.
    """
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
      return
    else:
      self._any_match(obj, flag)
      return 

  def _any_match(self, obj) -> Optional[F]:
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        return None
    else:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._any_match(obj)
      return None

  def any_match(self, obj: View[E,T,C]) -> Optional[F]:
    """
    See if view has a leaf node that exactly matches it. If yes,
    get the flag.
    """
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        return None
    else:
      return self._any_match(obj)

  def _iterate_leaves(self):
    if len(self.children) == 0:
      yield self.value
    else:
      for child in self.children:
        yield from child._iterate_leaves()

  def do_iter(self):
    return self._iterate_leaves()

  def _inner_str(self, indent) -> str:
    s = ''
    if len(self.children) == 0:
      s += ' ' * indent + 'FLAG ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
    else:
      s += ' ' * indent + 'AND ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
      for child in self.children:
        s += child._inner_str(indent+2)
    return s

  def __str__(self):
    return 'FlagTree\n' + self._inner_str(0)
