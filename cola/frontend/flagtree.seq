from block import Block,View

@dataclass(init=False)
class FlagTree[E,T,C,F]:
  """
  Set of flags corresponding to a partition defined by an AndPTree. See AndPTree for
  the to_flagtree function. This is extremely similar to the structure of AndPTree.
  You can incrementally build up the tree too. This does not check that your partitions
  don't overlap and what not because that would be expensive. If there would be multiple 
  matches for your query, the first match would be used.
  F = type of flag value
  """

  value: View[E,T,C]
  children: list[FlagTree[E,T,C,F]]
  flag: F # all nodes get this, even if they aren't leaves

  def __init__(self, flag: F, value: View[E,T,C]):
    self.value = value
    self.flag = flag
    self.children = []

  def __init__(self, flag: F, value: Block[E,T,C]):
    self.value = View(value)
    self.flag = flag
    self.children = []

  def __init__(self, value: View[E,T,C]):
    self.value = value
    self.children = []
    self.flag = F()

  def __init__(self, value: Block[E,T,C]):
    self.value = View(value)
    self.children = []
    self.flag = F()

  def add_child(self, child: FlagTree[E,T,C,F]):
    self.children.append(child)

  def set_or_branch(self, obj: View[E,T,C], flag: F):
    """
    See if view has a node dedicated to it in the tree. If yes,
    set the flag. Otherwise, add in the node in the appropriate location
    and set the flag.
    """
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
      return
    else:
      # see if we are the same
      assert obj.base.fully_contained(self.value.base)
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
        return
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child.set_or_branch(obj, flag)
          return
      # if reached here, then we can't go down another level, so we add ourself here    
      ft = FlagTree(flag, obj)
      self.add_child(ft)

  def _iterate_leaves(self):
    if len(self.children) == 0:
      yield self.value
    else:
      for child in self.children:
        yield from child._iterate_leaves()

  def do_iter(self):
    return self._iterate_leaves()

  # TODO support reading/writing from multiple flags values if obj spans over multiple nodes
  # TODO if I had a separate getitem wrapper, I wouldn't have to check containment in the base case
  # each time (cause other than the first iteration, the base case is only reached IF obj is fully contained
  # in self.) Same goes for setitem
  def __getitem__(self, obj: View[E,T,C]) -> Optional[F]:
    """
    Get flag value out of the node that completely encapsluates obj (or return None).
    """
    if len(self.children) == 0:
      if obj.base.fully_contained(self.value.base):
        return self.flag
      else:
        return None
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child[obj]
      # didn't find a node
      return None
      
  def __setitem__(self, obj: View[E,T,C], flag: F):
    """
    Set flag value out for the node that completely encapsluates obj (or fail)
    """    
    if len(self.children) == 0:
      assert obj.base.fully_contained(self.value.base)
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child[obj] = flag
          found = True
          break
      assert found

  def _inner_str(self, indent) -> str:
    s = ''
    if len(self.children) == 0:
      s += ' ' * indent + 'FLAG ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
    else:
      s += ' ' * indent + 'AND ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
      for child in self.children:
        s += child._inner_str(indent+2)
    return s

  def __str__(self):
    return 'FlagTree\n' + self._inner_str(0)
