from block import Block,View
from error import ColaError

# TODO make an separate set of functions that don't fail 

@dataclass(init=False)
class FlagTree[E,T,C,F]:
  """
  Set of flags corresponding to a partition defined by an AndPTree. See AndPTree for
  the to_flagtree function. This is extremely similar to the structure of AndPTree.
  You can incrementally build up the tree too. This does not check that your partitions
  don't overlap and what not because that would be expensive. 

  There are several ways to access a FlagTree. See __getitem__, __setitem__, leaf_match, any_match.
  
  This is purely a location-based search, so you can use views and blocks of different element types
  to index.

  F = type of flag value
  """

  value: View[E,T,C]
  children: list[FlagTree[E,T,C,F]]
  flag: F # all nodes get this, even if they aren't leaves

  def __init__(self, flag: F, value: View[E,T,C]):
    self.value = value
    self.flag = flag
    self.children = []

  def __init__(self, flag: F, value: Block[E,T,C]):
    self.value = View(value)
    self.flag = flag
    self.children = []

  def __init__(self, value: View[E,T,C]):
    self.value = value
    self.children = []
    self.flag = F()

  def __init__(self, value: Block[E,T,C]):
    self.value = View(value)
    self.children = []
    self.flag = F()

  def add_child(self, child: FlagTree[E,T,C,F]):
    self.children.append(child)

  # TODO support reading/writing from multiple flags values if obj spans over multiple nodes
  # TODO if I had a separate getitem wrapper, I wouldn't have to check containment in the base case
  # each time (cause other than the first iteration, the base case is only reached IF obj is fully contained
  # in self.) Same goes for setitem

  def _getitem(self, obj) -> F:
    if len(self.children) == 0:
      return self.flag
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._getitem(obj)
      # didn't find a node
      raise ColaError('obj does not have appropriate location in tree')

  def __getitem__[E2](self, obj: View[E2,T,C]) -> F:
    """
    Get flag value out of the leaf that completely encapsluates obj (or fail if does not exist).
    """
    if len(self.children) == 0:
      if obj.base.fully_contained(self.value.base):
        return self.flag      
      else:
        raise ColaError('obj does not have appropriate location in tree') 
    else:
      return self._getitem(obj)

  def _setitem(self, obj, flag):
    if len(self.children) == 0:
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child[obj] = flag
          found = True
          break
      if not found:
        raise ColaError('obj does not have appropriate location in tree')

  def __setitem__[E2](self, obj: View[E2,T,C], flag: F):
    """
    Set flag value out for the leaf that completely encapsluates obj (or fail if does not exist)
    """    
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._setitem(obj, flag)
          found = True
          break
      if not found:
        raise ColaError('obj does not have appropriate location in tree')

  def _leaf_match(self, obj, flag):
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it
        ft = FlagTree(flag, obj)
        self.add_child(ft)
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._leaf_match(obj, flag)
          found = True
      if not found:
        raise ColaError('obj does not have appropriate location in tree')

  def leaf_match[E2](self, obj: View[E2,T,C], flag: F):
    """
    See if obj has a leaf node that exactly matches it. If yes,
    set the flag. Otherwise, add in the node in the appropriate location
    and set the flag.
    """
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)      
    else:
      self._leaf_match(obj, flag)

  def _leaf_match(self, obj) -> F:
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        raise ColaError('obj does not have appropriate location in tree')
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._leaf_match(obj)
      raise ColaError('obj does not have appropriate location in tree')

  def leaf_match[E2](self, obj: View[E2,T,C]) -> F:
    """
    See if obj has a leaf node that exactly matches it. If yes,
    get the flag. Otherwise, fail.
    """ 
    if obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        raise ColaError('obj does not have appropriate location in tree')        
    else:
      return self._leaf_match(obj)

  def _any_match(self, obj, flag):
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)    
    else:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        found = False
        for child in self.children:
          if obj.base.fully_contained(child.value.base):
            child._any_match(obj, flag)            
            found = True
            break
        if not found:
          # if reached here, then we can't go down another level, so we add ourself here    
          ft = FlagTree(flag, obj)
          self.add_child(ft)

  def any_match[E2](self, obj: View[E2,T,C], flag: F):
    """
    See if view has a leaf node that exactly matches it. If yes,
    set the flag. Otherwise, add in the node in the appropriate location
    and set the flag.
    """
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        # change this flag
        self.flag = flag
      else:
        # If we are here, it didn't exist, so make a node and set it      
        ft = FlagTree(flag, obj)
        self.add_child(ft)
    else:
      self._any_match(obj, flag)

  def _any_match(self, obj) -> F:
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        raise ColaError('obj does not have appropriate location in tree')
    else:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._any_match(obj)
      raise ColaError('obj does not have appropriate location in tree')

  def any_match[E2](self, obj: View[E2,T,C]) -> F:
    """
    See if view has a leaf node that exactly matches it. If yes,
    get the flag. Otherwise, fail.
    """
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      if obj.base.is_same_region(self.value.base):
        return self.flag
      else:
        raise ColaError('obj does not have appropriate location in tree')
    else:
      return self._any_match(obj)

  def _iterate_leaves(self):
    if len(self.children) == 0:
      yield self.value
    else:
      for child in self.children:
        yield from child._iterate_leaves()

  def do_iter(self):
    return self._iterate_leaves()

  def _inner_str(self, indent) -> str:
    s = ''
    if len(self.children) == 0:
      s += ' ' * indent + 'FLAG ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
    else:
      s += ' ' * indent + 'AND ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
      for child in self.children:
        s += child._inner_str(indent+2)
    return s

  def __str__(self):
    return 'FlagTree\n' + self._inner_str(0)
