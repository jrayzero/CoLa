from block import Block,View
from error import ColaError

# TODO make an separate set of functions that don't fail 

# NOTE: you can shoot yourself in the foot with a flagtree if you make it all manually. I recommend
# building it in line with an AndPTree


@dataclass(init=False)
class FlagTree[E,T,C,F]:
  """
  Set of flags corresponding to a partition defined by an AndPTree. See AndPTree for
  the to_flagtree function. This is extremely similar to the structure of AndPTree.
  You can incrementally build up the tree too. This does not check that your partitions
  don't overlap and what not because that would be expensive. 

  Access semantics:
  ** __getitem__: looks for the leaf that completely encapsulates the region specified. Fails if doesn't exist.
  ** get_cover: looks for any node in the tree that MATCHES (i.e. has same coverage) as the region specified. Fails if doesn't exist.
  ** __setitem__: looks for the leaf that completely encapsulates the region specified and sets the flag. Fails if doesn't exist.
  ** NOT YET set_leaf_unstrict: looks for the leaf that completely encapsulates the region specified and sets the flag. Adds region if doesn't exist.
  ** set_cover: looks for any node in the tree that MATCHES (i.e. has same coverage) as the region specified and sets the flag. Fails if doesn't exist.
  ** set_cover_unstrict: looks for any node in the tree that MATCHES (i.e. has same coverage) as the region specified and sets the flag. Adds region if doesn't exist.
  
  This is purely a location-based search, so you can use views and blocks of different element types
  to index.

  F = type of flag value
  """

  value: View[E,T,C]
  children: list[FlagTree[E,T,C,F]]
  flag: F # all nodes get this, even if they aren't leaves

  def __init__(self, flag: F, value: View[E,T,C]):
    self.value = value
    self.flag = flag
    self.children = []

  def __init__(self, flag: F, value: Block[E,T,C]):
    self.value = View(value)
    self.flag = flag
    self.children = []

  def __init__(self, value: View[E,T,C]):
    self.value = value
    self.children = []
    self.flag = F()

  def __init__(self, value: Block[E,T,C]):
    self.value = View(value)
    self.children = []
    self.flag = F()

  def add_child(self, child: FlagTree[E,T,C,F]):
    self.children.append(child)

  def __getitem__[E2](self, obj: Block[E2,T,C]) -> F:
    return self[View(obj)]

  def __getitem__[E2](self, obj: View[E2,T,C]) -> F:
    """
    Looks for the leaf that completely encapsulates the region specified. Fails if doesn't exist.
    """
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree') 
    if len(self.children) == 0:
      return self.flag      
    else:
      return self._getitem_inner(obj)

  def _getitem_inner(self, obj) -> F:
    if len(self.children) == 0:
      return self.flag
    else:
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          return child._getitem_inner(obj)
      # didn't find a node
      raise ColaError('obj does not have appropriate location in tree')

  def get_cover[E2](self, obj: Block[E2,T,C]) -> F:
    return self.get_cover(View(obj))

  def get_cover[E2](self, obj: View[E2,T,C]) -> F:
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      return self.flag
    elif len(self.children) == 0:
      raise ColaError('obj does not have appropriate location in tree')
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        return child._get_cover_inner(obj)
    raise ColaError('obj does not have appropriate location in tree')

  def _get_cover_inner(self, obj) -> F:
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      return self.flag
    elif len(self.children) == 0:
      raise ColaError('obj does not have appropriate location in tree')
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        return child._get_cover_inner(obj)
    raise ColaError('obj does not have appropriate location in tree')

  def __setitem__[E2](self, obj: Block[E2,T,C], flag: F):
    self[View(obj)] = flag

  def __setitem__[E2](self, obj: View[E2,T,C], flag: F):
    """
    Looks for the leaf that completely encapsulates the region specified and sets the flag. Fails if doesn't exist.
    """    
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    if len(self.children) == 0:
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._setitem_inner(obj, flag)
          found = True
          break
      if not found:
        raise ColaError('obj does not have appropriate location in tree')

  def _setitem_inner(self, obj, flag):
    if len(self.children) == 0:
      self.flag = flag
    else:
      found = False
      for child in self.children:
        if obj.base.fully_contained(child.value.base):
          child._setitem_inner(obj, flag)
          found = True
          break
      if not found:
        raise ColaError('obj does not have appropriate location in tree')

  def set_cover[E2](self, obj: Block[E2,T,C], flag: F):
    self.set_cover(View(obj), flag)

  def set_cover[E2](self, obj: View[E2,T,C], flag: F):
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      self.flag = flag
      return
    elif len(self.children) == 0:
      raise ColaError('obj does not have appropriate location in tree')
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    found = False
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        found = True
        child._set_cover_inner(obj, flag)
        break
    if not found:
      raise ColaError('obj does not have appropriate location in tree')
    
  def _set_cover_inner[E2](self, obj: View[E2,T,C], flag: F):
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      self.flag = flag
      return
    elif len(self.children) == 0:
      raise ColaError('obj does not have appropriate location in tree')
    found = False
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        found = True
        child._set_cover_inner(obj, flag)
        break
    if not found:
      raise ColaError('obj does not have appropriate location in tree')

  def set_cover_unstrict[E](self, obj: Block[E,T,C], flag: F):
    self.set_cover_unstrict(View(obj), flag)

  def set_cover_unstrict[E](self, obj: View[E,T,C], flag: F):
    """
    CAUTION: this function does not check that you add non-overlapping regions (neither
    does PTree cause it's too expensive). Obviously
    overlapping regions are fine for children blocks, but not good for siblings. If there 
    are overlapping siblings (that both match the coverage), then doing a getitem-like operation
    later will return the first of the possibly-overlapping options, which is probably not what you want.
    """
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      self.flag = flag
      return
    if len(self.children) == 0:
      # in this case, we have to try adding new node here
      if obj.base.fully_contained(self.value.base):
        ft = FlagTree(flag, obj)
        self.add_child(ft)
        return
      else:
        raise ColaError('obj does not have appropriate location in tree')
    if not obj.base.fully_contained(self.value.base):
      raise ColaError('obj does not have appropriate location in tree')
    found = False
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        found = True
        child._set_cover_unstrict_inner(obj, flag)
        break
    if not found:
      # didn't find it, need to add here
      ft = FlagTree(flag, obj)
      self.add_child(ft)

  def _set_cover_unstrict_inner[E](self, obj: View[E,T,C], flag: F):
    if self.value.dims() == obj.dims() and self.value.cgrid_mapping() == obj.cgrid_mapping():
      self.flag = flag
      return
    if len(self.children) == 0:
      ft = FlagTree(flag, obj)
      self.add_child(ft)
      return
    found = False
    for child in self.children:
      if obj.base.fully_contained(child.value.base):
        found = True
        child._set_cover_unstrict_inner(obj, flag)
        break
    if not found:
      # didn't find it, need to add here
      ft = FlagTree(flag, obj)
      self.add_child(ft)

#  def _leaf_match(self, obj, flag):
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        # change this flag
#        self.flag = flag
#      else:
#        # If we are here, it didn't exist, so make a node and set it
#        ft = FlagTree(flag, obj)
#        self.add_child(ft)
#    else:
#      found = False
#      for child in self.children:
#        if obj.base.fully_contained(child.value.base):
#          child._leaf_match(obj, flag)
#          found = True
#      if not found:
#        raise ColaError('obj does not have appropriate location in tree')
#
#  def leaf_match[E2](self, obj: View[E2,T,C], flag: F):
#    """
#    See if obj has a leaf node that exactly matches it. If yes,
#    set the flag. Otherwise, add in the node in the appropriate location
#    and set the flag.
#    """
#    if not obj.base.fully_contained(self.value.base):
#      raise ColaError('obj does not have appropriate location in tree')
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        # change this flag
#        self.flag = flag
#      else:
#        # If we are here, it didn't exist, so make a node and set it      
#        ft = FlagTree(flag, obj)
#        self.add_child(ft)      
#    else:
#      self._leaf_match(obj, flag)
#
#  def _leaf_match(self, obj) -> F:
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        return self.flag
#      else:
#        raise ColaError('obj does not have appropriate location in tree')
#    else:
#      for child in self.children:
#        if obj.base.fully_contained(child.value.base):
#          return child._leaf_match(obj)
#      raise ColaError('obj does not have appropriate location in tree')
#
#  def leaf_match[E2](self, obj: View[E2,T,C]) -> F:
#    """
#    See if obj has a leaf node that exactly matches it. If yes,
#    get the flag. Otherwise, fail.
#    """ 
#    if obj.base.fully_contained(self.value.base):
#      raise ColaError('obj does not have appropriate location in tree')
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        return self.flag
#      else:
#        raise ColaError('obj does not have appropriate location in tree')        
#    else:
#      return self._leaf_match(obj)
#
#  def _any_match(self, obj, flag):
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        # change this flag
#        self.flag = flag
#      else:
#        # If we are here, it didn't exist, so make a node and set it      
#        ft = FlagTree(flag, obj)
#        self.add_child(ft)    
#    else:
#      if obj.base.is_same_region(self.value.base):
#        # change this flag
#        self.flag = flag
#      else:
#        found = False
#        for child in self.children:
#          if obj.base.fully_contained(child.value.base):
#            child._any_match(obj, flag)            
#            found = True
#            break
#        if not found:
#          # if reached here, then we can't go down another level, so we add ourself here    
#          ft = FlagTree(flag, obj)
#          self.add_child(ft)
#
#  def any_match[E2](self, obj: View[E2,T,C], flag: F):
#    """
#    See if view has a leaf node that exactly matches it. If yes,
#    set the flag. Otherwise, add in the node in the appropriate location
#    and set the flag.
#    """
#    if not obj.base.fully_contained(self.value.base):
#      raise ColaError('obj does not have appropriate location in tree')
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        # change this flag
#        self.flag = flag
#      else:
#        # If we are here, it didn't exist, so make a node and set it      
#        ft = FlagTree(flag, obj)
#        self.add_child(ft)
#    else:
#      self._any_match(obj, flag)
#
#  def _any_match(self, obj) -> F:
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        return self.flag
#      else:
#        raise ColaError('obj does not have appropriate location in tree')
#    else:
#      if obj.base.is_same_region(self.value.base):
#        return self.flag
#      for child in self.children:
#        if obj.base.fully_contained(child.value.base):
#          return child._any_match(obj)
#      raise ColaError('obj does not have appropriate location in tree')
#
#  def any_match[E2](self, obj: View[E2,T,C]) -> F:
#    """
#    See if view has a leaf node that exactly matches it. If yes,
#    get the flag. Otherwise, fail.
#    """
#    if not obj.base.fully_contained(self.value.base):
#      raise ColaError('obj does not have appropriate location in tree')
#    if len(self.children) == 0:
#      if obj.base.is_same_region(self.value.base):
#        return self.flag
#      else:
#        raise ColaError('obj does not have appropriate location in tree')
#    else:
#      return self._any_match(obj)

  def _iterate_leaves(self):
    if len(self.children) == 0:
      yield self.value
    else:
      for child in self.children:
        yield from child._iterate_leaves()

  def do_iter(self):
    return self._iterate_leaves()

  def _inner_str(self, indent) -> str:
    s = ''
    if len(self.children) == 0:
      s += ' ' * indent + 'FLAG ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
    else:
      s += ' ' * indent + 'AND ' + str(self.value.dims()) + '@' + str(self.value.origin()) + '(value=' + str(self.flag) + ')\n'
      for child in self.children:
        s += child._inner_str(indent+2)
    return s

  def __str__(self):
    return 'FlagTree\n' + self._inner_str(0)

