from block import Block,View
from flagtree import FlagTree
from error import ColaError

# Note: once the parser is redone, this code should never be used directly. Rather, it should just
# be generated by the parser during the AST stage because there are constraints not expressable here (such as 
# not allowing intermediate computations in the ptree "meta language". Also, you can't call other functions and stuff). 
# It will get lowered to loops also (so there is no interpreter-only version), which is why there isn't really anything here.
# Having this lets us utilize the type checking though.

# in compiler: check children is tuple of PTrees

@dataclass(init=False)
class AndGroup[E,T,C]:

  def __init__(self):
    raise ColaError("Function should not exist in code generation")

  def __iter__(self) -> Generator[View[E,T,C]]:
    raise ColaError("Function should not exist in code generation")

@dataclass(init=False)
class InnerPTree[E,T,C]:
  
  def build(children: list[InnerPTree[E,T,C]]) -> InnerPTree[E,T,C]:
    raise ColaError("Function should not exist in code generation")

@dataclass(init=False)
class PTree[E,T,C]:

  def build(child: InnerPTree[E,T,C]) -> PTree[E,T,C]:
    raise ColaError("Function should not exist in code generation")

  def __iter__(self) -> Generator[AndGroup[E,T,C]]:
    raise ColaError("Function should not exist in code generation")
    #yield AndGroup[E,T,C]()

@dataclass(init=False)
class AndNode[E,T,C]:
  
  def build(children: list[InnerPTree[E,T,C]]) -> InnerPTree[E,T,C]:
    raise ColaError("Function should not exist in code generation")

@dataclass(init=False)
class OrNode[E,T,C]:

  def build(children: list[InnerPTree[E,T,C]]) -> InnerPTree[E,T,C]:
    raise ColaError("Function should not exist in code generation")

@dataclass(init=False)
class LeafNode[E,T,C]:

  def build(leaf: View[E,T,C]) -> InnerPTree[E,T,C]:
    raise ColaError("Function should not exist in code generation")
  
def do_debug():
  master_root = Block.make[int](16,16)

  """
  Anticipated format
  No nested functions and no recursion!
  @ptree
  def build(root):
    h = root.dims(0)
    pt_or:
      pt_leaf root
      pt_and:
        pt_leaf root[:,h//2:]
        pt_leaf root[:,:h//2]
      pt_and:
        pt_leaf root[h//2:,:]
        pt_leaf root[:h//2,:]
      pt_and:
        pt_leaf root[h//2:,h//2:]
        pt_leaf root[h//2:,:h//2]
        pt_leaf root[:h//2,h//2:]
        pt_leaf root[:h//2,:h//2]
  """

  def do_build(root):  
    tree = PTree.build(OrNode.build([
      AndNode.build([LeafNode.build(root[:,:])]),
      AndNode.build([LeafNode.build(root[0:root.dims(0)//2,0:root.dims(1)]), 
                     LeafNode.build(root[root.dims(0)//2:root.dims(0),0:root.dims(1)])]),
      AndNode.build([LeafNode.build(root[0:root.dims(0),0:root.dims(1)//2]), 
                     LeafNode.build(root[0:root.dims(0),root.dims(1)//2:root.dims(1)])]),
      AndNode.build([LeafNode.build(root[0:root.dims(0)//2,0:root.dims(1)//2]), 
                     LeafNode.build(root[0:root.dims(0)//2,root.dims(1)//2:root.dims(1)]), 
                     LeafNode.build(root[root.dims(0)//2:root.dims(0),0:root.dims(1)//2]), 
                     LeafNode.build(root[root.dims(0)//2:root.dims(0),root.dims(1)//2:root.dims(1)])])]))
    return tree

  i = do_build(master_root)
  for and_group in i:
    pass
#  for and_group in build(master_root):
#    for leaf in and_group:
#      if leaf.dims(0) == 4:
#        # figure out the best 4x4 node
#        for and_group2 in build(leaf):
#          for leaf2 in and_group2:
#            print 'leaf2'
#            print leaf2.cgrid_mapping()
#      else:
#        print 'leaf'
#        print leaf.cgrid_mapping()

do_debug()
