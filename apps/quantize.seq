from ..cola.frontend.lut import *
from ..cola.frontend.block import *
import math

# TODO adaptive rounding

class Quantize:

  # TODO either add a "lookup_table" tag, or see if can have class variable 
  # attached to Quantize, so can do Quantize.mf4 or something. This is just a 
  # constant lookup table! 
  def m4x4():
    """
    See Table 7.4 in Richardson's book
    """
    return LUT((6, 3),
               [13107, 5243, 8066,
                11916, 4660, 7490,
                10082, 4194, 6554,
                9362, 3647, 5825,
                8192, 3355, 5243,
                7282, 2893, 4559])
  
  # For the MfN matrices, the 2x2 (Mf4) and 4x4 (Mf8) quadrants are all the same, so 
  # we could make a smaller lookup table. But they aren't very big anyway, so oh well

  def Mf4(QP: int):
    """
    See page 194 in Richardson's book
    """
    mod = QP % 6
    m = Quantize.m4x4()
    return LUT((4, 4),
               [m(mod,0), m(mod,2), m(mod,0), m(mod,2),
                m(mod,2), m(mod,1), m(mod,2), m(mod,1),
                m(mod,0), m(mod,2), m(mod,0), m(mod,2),
                m(mod,2), m(mod,1), m(mod,2), m(mod,1)])

  def quantize_4x4(coeffs, QP: int):
    """
    See page 195 in Richardson's book (except I don't use adaptive rounding)
    """
    Mf4 = Quantize.Mf4(QP)
    tmp = float(Mf4 * coeffs)
    q = int(BlockOps.round(tmp * (1/(2**(15+QP//6)))))
    return q

  # TODO I don't know if the stuff for 8x8 is correct, cause the book basically ignores
  # a bunch of the final details after telling you how to compute Mf8.

  def v8x8():
    """
    See table on top of page 202 in Richardson's book
    """
    return LUT((6,6),
               [20, 18, 32, 19, 25, 24,
                22, 19, 35, 21, 28, 26,
                26, 23, 42, 24, 33, 31,
                28, 25, 45, 26, 35, 33,
                32, 28, 51, 30, 40, 38,
                36, 32, 58, 34, 46, 43])

  def Vi8(QP: int):
    """
    See second table on page 202 in Richardson's book
    """
    mod = QP % 6
    v = Quantize.v8x8()
    return LUT((8,8), 
               [v(mod,0),v(mod,3),v(mod,4),v(mod,3),v(mod,0),v(mod,3),v(mod,4),v(mod,3),
                v(mod,3),v(mod,1),v(mod,5),v(mod,1),v(mod,3),v(mod,1),v(mod,5),v(mod,1),
                v(mod,4),v(mod,5),v(mod,2),v(mod,5),v(mod,4),v(mod,5),v(mod,2),v(mod,5),
                v(mod,3),v(mod,1),v(mod,5),v(mod,1),v(mod,3),v(mod,1),v(mod,5),v(mod,1),
                v(mod,0),v(mod,3),v(mod,4),v(mod,3),v(mod,0),v(mod,3),v(mod,4),v(mod,3),
                v(mod,3),v(mod,1),v(mod,5),v(mod,1),v(mod,3),v(mod,1),v(mod,5),v(mod,1),
                v(mod,4),v(mod,5),v(mod,2),v(mod,5),v(mod,4),v(mod,5),v(mod,2),v(mod,5),
                v(mod,3),v(mod,1),v(mod,5),v(mod,1),v(mod,3),v(mod,1),v(mod,5),v(mod,1)])

  def Sf8():
    return LUT((8,8), 
               [1/512, 1/544, 1/(128*math.sqrt(10)), 1/544, 1/512, 1/544, 1/(128*math.sqrt(10)), 1/544, 
                1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 
                1/(128*math.sqrt(10)), 1/(136*math.sqrt(10)), 1/320, 1/(136*math.sqrt(10)), 1/(128*math.sqrt(10)), 1/(136*math.sqrt(10)), 1/320, 1/(136*math.sqrt(10)), 
                1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 1/544, 1/578, 1/(136*math.sqrt(10)), 1/578,
                1/512, 1/544, 1/(128*math.sqrt(10)), 1/544, 1/512, 1/544, 1/(128*math.sqrt(10)), 1/544, 
                1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 
                1/(128*math.sqrt(10)), 1/(136*math.sqrt(10)), 1/320, 1/(136*math.sqrt(10)), 1/(128*math.sqrt(10)), 1/(136*math.sqrt(10)), 1/320, 1/(136*math.sqrt(10)), 
                1/544, 1/578, 1/(136*math.sqrt(10)), 1/578, 1/544, 1/578, 1/(136*math.sqrt(10)), 1/578])
               

  def Si8():
    return LUT((8,8),
               [1/8, 2/17, 1/(math.sqrt(40)), 2/17, 1/8, 2/17, 1/(math.sqrt(40)), 2/17,
                2/17, 32/289, 8/(17*math.sqrt(10)), 32/289, 2/17, 32/289, 8/(17*math.sqrt(10)), 32/289,
                1/(math.sqrt(40)), 8/(17*math.sqrt(10)), 1/5, 8/(17*math.sqrt(10)), 1/(math.sqrt(40)), 8/(17*math.sqrt(10)), 1/5, 8/(17*math.sqrt(10)),
                2/17, 32/289, 8/(17*math.sqrt(10)), 32/289, 2/17, 32/289, 8/(17*math.sqrt(10)), 32/289,
                1/8, 2/17, 1/(math.sqrt(40)), 2/17, 1/8, 2/17, 1/(math.sqrt(40)), 2/17,
                2/17, 32/289, 8/(17*math.sqrt(10)), 32/289, 2/17, 32/289, 8/(17*math.sqrt(10)), 32/289,
                1/(math.sqrt(40)), 8/(17*math.sqrt(10)), 1/5, 8/(17*math.sqrt(10)), 1/(math.sqrt(40)), 8/(17*math.sqrt(10)), 1/5, 8/(17*math.sqrt(10)),
                2/17, 32/289, 8/(17*math.sqrt(10)), 32/289, 2/17, 32/289, 8/(17*math.sqrt(10)), 32/289
               ])

  def S8():
    return Quantize.Si8() * Quantize.Sf8()

  def Mf8(QP: int):
    Vi8 = Quantize.Vi8(QP)
    Mf8 = Quantize.S8() * float(2**30) / float(Vi8)
    return Mf8

  def quantize_8x8(coeffs, QP: int):
    
    Mf8 = int(BlockOps.round(Quantize.Mf8(QP)))
    tmp = float(Mf8 * coeffs)
    q = int(BlockOps.round(tmp * (1/(2**(22+QP//6)))))    
    return q

def do_test():
  print 'Running quantize.seq tests'
  # 4x4 follows example from Richardson book
  blk4x4 = Block.make[int](4,4)
  blk4x4[0] = 961
  blk4x4[1] = -41
  blk4x4[2] = 15
  blk4x4[3] = -48
  blk4x4[4] = -34
  blk4x4[5] = 72
  blk4x4[6] = -30
  blk4x4[7] = -104
  blk4x4[8] = -15
  blk4x4[9] = 3
  blk4x4[10] = 15
  blk4x4[11] = 24
  blk4x4[12] = 13
  blk4x4[13] = 81
  blk4x4[14] = -5
  blk4x4[15] = 8
  @test
  def t0():
    # qp = 6
    quant = Quantize.quantize_4x4(blk4x4, 6)
    assert quant == [192, -5, 3, -6, -4, 6, -4, -8, -3, 0, 3, 3, 2, 6, -1, 1]
  t0()
  @test
  def t1():
    # qp = 18
    quant = Quantize.quantize_4x4(blk4x4, 18)
    assert quant == [48, -1, 1, -1, -1, 1, -1, -2, -1, 0, 1, 1, 0, 2, 0, 0]
  t1()
  blk8x8 = Block.make((8,8), 
                      [961, -41, 15, -48, -34, 72, -30, -104,
                       -15, 3, 15, 24, 13, 81, -5, 8,
                       961, -41, 15, -1050, -34, 72, -30, -104,
                       -15, 3, 15, 24, 13, 81, -5, 8,
                       961, -41, 15, -48, -34, 72, -30, -104,
                       -15, 3, 15, 3700, 13, 81, -5, 8,
                       961, -41, 15, -48, -34, 72, -30, -104,
                      -15, 3, 15, 24, 13, 81, -5, 8,
                      ])
  @test
  def t2():
    # qp = 2
    quant = Quantize.quantize_8x8(blk8x8, 2)
    assert quant == [2,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,
                     3,0,0,-3,0,0,0,0,
                     0,0,0,0,0,0,0,0,
                     2,0,0,0,0,0,0,0,
                     0,0,0,8,0,0,0,0,
                     3,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0]
  t2()
