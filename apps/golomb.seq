from ..cola.frontend.bits import *
from ..cola.frontend.scan import *
from ..cola.frontend.lut import *
import math

# Library

class ExpGolomb:

  def encode_ue[N:int](k: int, codeword: Bits[N]):
    """
    Unsigned direct mapping
    k: value to encode
    codeword: sequence to pack into
    """
    ExpGolomb.encode(k, codeword)

  def decode_ue[N:int](codeword: Bits[N]) -> int:
    """
    Unsigned direct mapping
    """
    return ExpGolomb.decode(codeword)

  def encode_te[N:int](k: int, max_k: int, codeword: Bits[N]):
    """
    Truncated mapping
    k: value to encode
    max_k: max value of ks
    codeword: sequence to pack into
    """ 
    if max_k == 1:
      ExpGolomb.encode(int(not bool(k)))
    else:
      ExpGolomb.encode(k, codeword)

  def decode_te[N:int](max_k: int, codeword: Bits[N]) -> int:
    """
    Truncated mapping
    """
    b = ExpGolomb.decode(codeword)
    if max_k == 1:          
      return int(not bool(b))
    else:
      return b  

  def encode_se[N:int](k: int, codeword: Bits[N]):
    """
    Signed mapping 
    k: value to encode
    codeword: sequence to pack into
    """
    codenum = 2 * abs(k) - int(k>0)
    ExpGolomb.encode(codenum, codeword)

  def decode_se[N:int](codeword: Bits[N]):
    """
    Signed mapping 
    """
    codenum = ExpGolomb.decode(codeword)
    return (-1)**(codenum+1)*int(math.ceil(codenum/2))

  def encode_me[N:int](k: int, codeword: Bits[N], table: LUT[Tuple[int,int],Tuple[int]]):
    """
    Mapped symbols
    k: value to encode
    codeword: sequence to pack into
    table: the mappings, returning the codenum and nbits for k
    """
    codenum,nbits = table[k]
    ExpGolomb.encode(codenum, nbits)

  def decode_me[N:int](codeword: Bits[N], table: LUT[int,Tuple[int]]):
    """
    Mapped symbols
    table: the mappings, returning k for codenum
    """
    codenum = ExpGolomb.decode(codeword)
    return table[codenum]    
  
  def encode[N:int](codenum: int, codeword: Bits[N]):
    """
    codenum: value to encode
    codeword: sequence to pack into
    """
    M = int(math.floor(math.log2(codenum+1)))
    INFO = codenum+1-2**M
    for _ in range(M):
      codeword.pack(0,1)
    codeword.pack(1,1)
    codeword.pack(INFO,M)

  def decode[N:int](codeword: Bits[N]) -> int:
    """
    Decode the leading bits in codeword and remove them from codeword.
    """
    M = 0
    for bit in scan(codeword):
      if not bit:
        M += 1
      else:
        break
    codeword.unpack(M+1) # remove the leading zeros and 1 delimiter
    INFO = int(codeword.unpack(M))
    return 2**M + INFO - 1

@test
def do_test():
  print 'Running Golomb tests'
  codenum = 107
  codeword = Bits[64]()
  ExpGolomb.encode(codenum, codeword)
  actual = Bits[64]()
  actual.pack(108,13)
  assert codeword == actual
  codenum = ExpGolomb.decode(codeword)
  assert codenum == 107
  codeword.pack(227, 15)
  assert ExpGolomb.decode(codeword) == 226
  
  k = -137
  ExpGolomb.encode_se(k, codeword)
  assert ExpGolomb.decode_se(codeword) == k
  
