from ..cola.frontend.block import *
from ..cola.frontend.scan import scan
from ..cola.frontend.flagtree import *
from partition import *
from utils import *
from constants import *

# TODO I think I do actually need slice information even though the standard doesn't really specify it
# TODO this all assumes 2D indexing, which I may not want 
# TODO support I_PCM
# TODO make better names for the arguments. 
# TODO for each mode, add a comment pointing to its location in the standard

# For checking availability,I just look at a single pixel within the region since that is enough to check for availability of
# the entire region.

class H264IntraCommon:

  # checks mb type
  def check_params(to_pred_region, surrounding_pixels, mb_type_info, pred_info, constrained_intra_pred_flag):
    """
    @ARG(to_pred_region, TO_PRED)
    @ARG(surrounding_pixels): The reference pixels to check params on.
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    if surrounding_pixels.exists():
      if constrained_intra_pred_flag:
        if not pred_info(surrounding_pixels):
          # was inter
          return False
      if mb_type_info(to_pred_region[0,0]) == SI_SLICE and mb_type_info(surrounding_pixels) != SI_SLICE:
        return False
      return True
    else:
      return False

  def left_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check left availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    left = ref_colocated[0,-1]
    return H264IntraCommon.check_params(to_pred_region, left, mb_type_info, pred_info, constrained_intra_pred_flag)

  def up_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up availability of to_pred_region in ref_colocated. 
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    up = ref_colocated[-1,0]
    return H264IntraCommon.check_params(to_pred_region, up, mb_type_info, pred_info, constrained_intra_pred_flag)

  def up_left_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up left availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    up_left = ref_colocated[-1,-1]
    return H264IntraCommon.check_params(to_pred_region, up_left, mb_type_info, pred_info, constrained_intra_pred_flag)

  # doesn't check mb type
  def check_params(to_pred_region, surrounding_pixels, pred_info, constrained_intra_pred_flag):
    """
    @ARG(to_pred_region, TO_PRED)
    @ARG(surrounding_pixels): The reference pixels to check params on.
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    if surrounding_pixels.exists():
      if constrained_intra_pred_flag:
        if not pred_info(surrounding_pixels):
          # was inter
          return False
      return True
    else:
      return False

  def left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check left availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    left = ref_colocated[0,-1]
    return H264IntraCommon.check_params(to_pred_region, left, pred_info, constrained_intra_pred_flag)

  def up_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up availability of to_pred_region in ref_colocated. 
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    up = ref_colocated[-1,0]
    return H264IntraCommon.check_params(to_pred_region, up, pred_info, constrained_intra_pred_flag)

  def up_left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up left availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    up_left = ref_colocated[-1,-1]
    return H264IntraCommon.check_params(to_pred_region, up_left, pred_info, constrained_intra_pred_flag)

  def up_right_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up right availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    up_right = ref_colocated[-1,8]
    return H264IntraCommon.check_params(to_pred_region, up_right, pred_info, constrained_intra_pred_flag)

class H264Intra16x16:

  def check_availability(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag: bool) -> Tuple[bool,bool,bool]:
    """
    Check left, right, and up left availability of 16x16 block.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    return H264IntraCommon.left_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_left_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag)

  def schedule_luma[E,T,C](to_pred_region: View[E,T,C], ref_region, mb_type_info, pred_info, constrained_intra_pred_flag: bool, bit_depth_Y: int):
    """
    Run all possible 16x16 modes according to availability.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_region, REF_REGION)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    @ARG(bit_depth_Y)
    """
    colocated = ref_region[to_pred_region]
    left,up,up_left = H264Intra16x16.check_availability(to_pred_region, colocated, mb_type_info, pred_info, constrained_intra_pred_flag)
    preds = Array[Optional[Block[E,T,C]]](4)
    # vertical
    preds[0] = None
    # horizontal
    preds[1] = None
    # DC
    preds[2] = Block(to_pred_region)
    # planar
    preds[3] = None
    if up:
      preds[0] = Block(to_pred_region)
      H264Intra16x16.vertical(preds[0], colocated)
    if left:
      preds[1] = Block(to_pred_region)
      H264Intra16x16.horizontal(preds[1], colocated)
    # DC + planar mode
    if up and left:
      H264Intra16x16.DC_a(preds[2], colocated)
      if up_left:
        preds[3] = Block(to_pred_region)
        H264Intra16x16.planar(preds[3], colocated, bit_depth_Y)
    elif left:
      H264Intra16x16.DC_b(preds[2], colocated)
    elif up:
      H264Intra16x16.DC_c(preds[2], colocated)
    else:
      H264Intra16x16.DC_d(preds[2], bit_depth_Y)
    return preds
      
  def vertical(pred, colocated):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, REF_REGION)
    """
    for i in range(pred.dims()[0]):
      pred[:,i] = colocated(-1,i)

  def horizontal(pred, colocated):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)
    """
    for i in range(pred.dims()[0]):
      pred[i,:] = colocated(i,-1)

  def DC_a(pred, colocated):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)
    """
    s = 16
    for i in range(pred.dims()[0]):
      s += colocated(-1,i) + colocated(i,-1)
    s >>= 5    
    pred[:,:] = s

  def DC_b(pred, colocated):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)
    """
    s = 8
    for i in range(pred.dims()[0]):
      s += colocated(i,-1)
    s >>= 4
    pred[:,:] = s

  def DC_c(pred, colocated):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)
    """
    s = 8
    for i in range(pred.dims()[0]):
      s += colocated(-1,i)
    s >>= 4
    pred[:,:] = s

  def DC_d(pred, bit_depth):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)
    """
    pred[:,:] = 1 << (bit_depth - 1)

  def planar(pred, colocated, bit_depth):
    """
    @ARG(pred, DO_PRED)
    @ARG(colocated, COLOCATED_REGION)    
    """
    # pull out the pieces to compute H    
    H = 0
    for i in range(8):
      H += (i+1) * (colocated(-1,8+i)-colocated(-1,i))    
    # and the pieces for V
    V = 0
    r = 0
    for i in range(8):
      V += (i+1) * (colocated(8+i,-1)-colocated(i,-1))
    a = 16 * (colocated(15,-1)+colocated(-1,15))
    b = (5 * H + 32) >> 6
    c = (5 * V + 32) >> 6
    for y in range(16):
      for x in range(16):
        clip_val = (a + b * (x - 7) + c * (y - 7) + 16) >> 5
        pred[y,x] = (clip1y(clip_val, bit_depth))

class H264Intra8x8:


  def check_availability(to_pred_region, ref_colocated, pred_info, \
                         constrained_intra_pred_flag: bool) -> Tuple[bool,bool,bool,bool]:
    """
    Check left, up left, up, and up right availability.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    return H264IntraCommon.left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_right_available[8](to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag)

  def schedule_luma[E,T,C](to_pred_region: View[E,T,C], ref_region, pred_info, constrained_intra_pred_flag: bool, bit_depth_Y: int):
    """
    Run all possible 8x8 modes according to availability.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_region, REF_REGION)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    @ARG(bit_depth_Y)
    """
    colocated = ref_region[to_pred_region]
    left,up_left,up,up_right = H264Intra8x8.check_availability(to_pred_region, colocated, pred_info, constrained_intra_pred_flag)
    filt_row,filt_col,up_right2 = H264Intra8x8.low_pass_filter(colocated, up, left, up_right, up_left)
    up_right = up_right2
    preds = Array[Optional[Block[E,T,C]]](9)
    # vertical
    preds[0] = None
    # horizontal
    preds[1] = None
    # DC
    preds[2] = Block(to_pred_region)
    # down left
    preds[3] = None
    # down right
    preds[4] = None
    # vertical right
    preds[5] = None
    # horizontal down
    preds[6] = None
    # vertical left
    preds[7] = None
    # horizontal up
    preds[8] = None
    if up:
      preds[0] = Block(to_pred_region)
      H264Intra8x8.vertical(preds[0], filt_row)
      if up_right:
        preds[3] = Block(to_pred_region)
        H264Intra8x8.diag_down_left(preds[3], filt_row)
        preds[7] = Block(to_pred_region)
        H264Intra8x8.vertical_left(preds[7], filt_row)
    if left:
      preds[1] = Block(to_pred_region)
      H264Intra8x8.horizontal(preds[1], filt_col)
      preds[8] = Block(to_pred_region)
      H264Intra8x8.horizontal_up(preds[8], filt_col)
    if up and left:
      H264Intra8x8.DC_a(preds[2], filt_row, filt_col)
      if up_left:
        preds[4] = Block(to_pred_region)
        H264Intra8x8.diag_down_right(preds[4], filt_row, filt_col)
        preds[5] = Block(to_pred_region)
        H264Intra8x8.vertical_right(preds[5], filt_row, filt_col)
        preds[6] = Block(to_pred_region)
        H264Intra8x8.horizontal_down(preds[6], filt_row, filt_col)
    elif left:
      H264Intra8x8.DC_b(preds[2], filt_col)
    elif up:
      H264Intra8x8.DC_c(preds[2], filt_row)
    else:
      H264Intra8x8.DC_d(preds[2], bit_depth_Y)
    return preds

  def vertical(pred, filt_row):
    for i in range(8):
      pred[:,i] = filt_row(0,i)

  def horizontal(pred, filt_col):
    for i in range(8):
      pred[i,:] = filt_col(i,0)

  def DC_a(pred, filt_row, filt_col):
    s = 8
    for i in range(8):
      s += filt_col(0,i) + filt_col(i,0)
    s >>= 4
    pred[:,:] = s

  def DC_b(pred, filt_col):
    s = 4
    for i in range(8):
      s += filt_col(i,0)
    s >>= 3
    pred[:,:] = s

  def DC_c(pred, filt_row):
    s = 4
    for i in range(8):
      s += filt_row(0,i)
    s >>= 3
    pred[:,:] = s

  def DC_d(pred, bit_depth):
    pred[:,:] = 1 << (bit_depth - 1)

  def diag_down_left(pred, filt_row):
    for y in range(8):
      for x in range(8):
        if x == 7 and y == 7:
          pred[y,x] = (filt_row(0,14) + 3 * filt_row(0,15) + 2) >> 2
        else:
          pred[y,x] = (filt_row(0,x+y) + 2*filt_row(0,x+y+1) + filt_row(0,x+y+2) + 2) >> 2

  def diag_down_right(pred, filt_row, filt_col):
    for y in range(8):
      for x in range(8):
        if x > y:
          pred[y,x] = (filt_row(0, x-y-2) + 2*filt_row(0,x-y-1) + filt_row(0,x-y) + 2) >> 2
        elif x < y:
          pred[y,x] = (filt_col(y-x-2,0) + 2*filt_col(y-x-1,0) + filt_col(y-x,0) + 2) >> 2
        else:
          pred[y,x] = filt_row(0,0) + 2

  def vertical_right(pred, filt_row, filt_col):
    for y in range(8):
      for x in range(8):
        zVR = 2*x-y
        if zVR == -1:
          pred[y,x] = (filt_col(0,0) + 2*filt_row(0,-1) + filt_row(0,0) + 2) >> 2
        elif zVR < 0:
          pred[y,x] = (filt_col(y-2*x-1,0) + 2*filt_col(y-2*x-2,0) + filt_col(y-2*x-3,0) + 2) >> 2
        elif zVR % 2 == 0:
          pred[y,x] = (filt_row(0,x-(y>>1)-1) + filt_row(0,x-(y>>1)) + 1) >> 1
        else:
          pred[y,x] = (filt_row(0,x-(y>>1)-2) + 2*filt_row(0,x-(y>>1)-1) + filt_row(0,x-(y>>1)) + 2) >> 2

  def horizontal_down(pred, filt_row, filt_col):
    for y in range(8):
      for x in range(8):
        zHD = 2*y-x
        if zHD == -1:
          pred[y,x] = (filt_col(0,0) + 2*filt_row(0,-1) + filt_row(0,0) + 2) >> 2
        elif zHD < 0:
          pred[y,x] = (filt_row(0,x-2*y-1) + 2*filt_row(0,x-2*y-2) + filt_row(0,x-2*y-3) + 2) >> 2
        elif zHD % 2 == 0:
          pred[y,x] = (filt_col(y-(x>>1)-1,0) + filt_col(y-(x>>1),0) + 1) >> 1
        else:
          pred[y,x] = (filt_col(y-(x>>1)-2,0) + 2*filt_col(y-(x>>1)-1,0) + filt_col(y-(x>>1),0) + 2) >> 2        

  def vertical_left(pred, filt_row):
    for y in range(8):
      for x in range(8):
        if y % 2 == 0:
          pred[y,x] = (filt_row(0,x+(y>>1)) + filt_row(0,x+(y>>1)+1) + 1) >> 1
        else:
          pred[y,x] = (filt_row(0,x+(y>>1)) + 2*filt_row(0,x+(y>>1)+1) + filt_row(0,x+(y>>1)+2) + 2) >> 1

  def horizontal_up(pred, filt_col):
    for y in range(8):
      for x in range(8):
        zHU = x+2*y
        if zHU == 13:
          pred[y,x] = (filt_col(6,0) + 3*filt_col(7,0) + 2) >> 2
        elif zHU > 13:
          pred[y,x] = filt_col(7,0)
        elif zHU % 2 == 0:
          pred[y,x] = (filt_col(y+(x>>1),0) + filt_col(y+(x>>1)+1,0) + 1) >> 1
        else:
          pred[y,x] = (filt_col(y+(x>>1),0) + 2*filt_col(y+(x>>1)+1,0) + filt_col(y+(x>>1)+2,0) + 2) >> 2

  # prefiltering pass for 8x8 reference data
  def low_pass_filter(colocated, up_available, left_available, up_right_available, up_left_available):
    # these filtered blocks may go out-of-bounds wrt the reg_region_8x8, but they won't be accessed it that is the case
    filt_row_blk = Block(colocated[-1,-1:16]) if up_left_available else Block(colocated[-1,0:16])
    filt_row = filt_row_blk[:,1:] if up_left_available else filt_row_blk[:,:]
    filt_col_blk = Block(colocated[-1:8,-1]) if up_left_available else Block(colocated[0:8,-1])
    filt_col = filt_col_blk[1:,:] if up_left_available else filt_col_blk[:,:]
    filt_diag = -1
    if up_available and up_right_available:
      if up_left_available:
        filt_row[0,0] = (colocated(-1,-1) + 2*colocated(-1,0) + colocated(-1,1) + 2) >> 2
      else:
        filt_row[0,0] = (3*colocated(-1,0) + colocated(-1,1) + 2) >> 2
      for x in range(1,15):
        filt_row[0,x] = (colocated(-1,x-1) + 2*colocated(-1,x) + colocated(-1,x+1) + 2) >> 2
      filt_row[0,15] = (colocated(-1,14) + 3*colocated(-1,15) + 2) >> 2
    if up_left_available:
      if up_available:
        filt_diag = (3*colocated(-1,-1) + colocated(-1,0) + 2) >> 2
      elif left_available:
        filt_diag = (3*colocated(-1,-1) + colocated(0,-1) + 2) >> 2
      else:
        filt_diag = colocated(-1,-1)
      filt_row_blk[0,0] = filt_diag
      filt_col_blk[0,0] = filt_diag
    if left_available:
      if up_left_available:
        filt_col[0,0] = (colocated(-1,1) + 2*colocated(0,-1) + colocated(1,-1) + 2) >> 2
      else:
        filt_col[0,0] = (3*colocated(0,-1) + colocated(1,-1) + 2) >> 2
      for y in range(1,7):
        filt_col[y,0] = (colocated(y-1,-1) + 2*colocated(y,-1) + colocated(y+1,-1) + 2) >> 2
      filt_col[7,0] = (colocated(6,-1) + 3*colocated(7,-1) + 2) >> 2
    if not up_right_available and up_available: # see clause 8.3.2.2, 3rd to last paragraph
      up_right_available = True
      filt_row[0,8:] = filt_row(0,7)
    return filt_row, filt_col, up_right_available


class H264Intra4x4:

  def up_right_available(to_pred_region, ref_colocated, mb_type_info, pred_info, constrained_intra_pred_flag) -> bool:    
    """
    Check up left availability of to_pred_region in ref_colocated.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    # check if idx within mb is 3 or 11. If so, this isn't available (clause 8.3.1.2 #2)
    mb = to_pred_region["macroblock"]
    mb_origin = to_pred_region.origin_within(mb)     
    if mb_origin == (4,4) or mb_origin == (12,4): # idx 3 or idx 11
      return False
    up_left = ref_colocated[-1,-1]
    return H264Intra4x4.check_params(to_pred_region, up_left, mb_type_info, pred_info, constrained_intra_pred_flag)

  # check left, up-left, up, and up-right
  def check_availability(to_pred_region, ref_colocated, pred_info, \
                         constrained_intra_pred_flag: bool) -> Tuple[bool,bool,bool,bool]:
    """
    Check left, up left, up, and up right availability.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_colocated, REF_COLOCATED)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    """
    return H264IntraCommon.left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_left_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264IntraCommon.up_available(to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag), \
      H264Intra4x4.up_right_available[8](to_pred_region, ref_colocated, pred_info, constrained_intra_pred_flag)
 
  def schedule_luma[E,T,C](to_pred_region: View[E,T,C], ref_region, mb_type_info, pred_info, constrained_intra_pred_flag: bool, bit_depth_Y: int):
    """
    Run all possible 4x4 modes according to availability.
    @ARG(to_pred_region, TO_PRED)
    @ARG(ref_region, REF_REGION)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    @ARG(bit_depth_Y)
    """
    colocated = ref_region[to_pred_region]
    left,up_left,up,up_right = H264Intra4x4.check_availability(to_pred_region, colocated, mb_type_info, pred_info, constrained_intra_pred_flag)
    preds = Array[Optional[Block[E,T,C]]](9)
    # vertical
    preds[0] = None
    # horizontal
    preds[1] = None
    # DC
    preds[2] = Block(to_pred_region)
    # down left
    preds[3] = None
    # down right
    preds[4] = None
    # vertical right
    preds[5] = None
    # horizontal down
    preds[6] = None
    # vertical left
    preds[7] = None
    # horizontal up
    preds[8] = None
    if up:
      preds[0] = Block(to_pred_region)
      H264Intra4x4.vertical(preds[0], colocated)
      if up_right:
        preds[3] = Block(to_pred_region)
        H264Intra4x4.diag_down_left(preds[3], colocated)
        preds[7] = Block(to_pred_region)
        H264Intra4x4.vertical_left(preds[7], colocated)
    if left:
      preds[1] = Block(to_pred_region)
      H264Intra4x4.horizontal(preds[1], colocated)
      preds[8] = Block(to_pred_region)
      H264Intra4x4.horizontal_up(preds[8], colocated)
    if up and left:
      H264Intra4x4.DC_a(preds[2], colocated)
      if up_left:
        preds[4] = Block(to_pred_region)
        H264Intra4x4.diag_down_right(preds[4], colocated)
        preds[5] = Block(to_pred_region)
        H264Intra4x4.vertical_right(preds[5], colocated)
        preds[6] = Block(to_pred_region)
        H264Intra4x4.horizontal_down(preds[6], colocated)
    elif left:
      H264Intra4x4.DC_b(preds[2], colocated)
    elif up:
      H264Intra4x4.DC_c(preds[2], colocated)
    else:
      H264Intra4x4.DC_d(preds[2], bit_depth_Y)
    return preds

  def vertical(pred, colocated):
    for i in range(4):
      pred[:,i] = colocated(-1,i)

  def horizontal(pred, colocated):
    for i in range(4):
      pred[i,:] = colocated(i,-1)

  def DC_a(pred, colocated):
    s = 4
    for i in range(4):
      s += colocated(-1,0) + colocated(-1,1) + colocated(-1,2) + colocated(-1,3)
      s += colocated(0,-1) + colocated(1,-1) + colocated(2,-1) + colocated(3,-1)
    pred[:,:] = s >> 3

  def DC_b(pred, colocated):
    s = 2
    for i in range(4):
      s += colocated(0,-1) + colocated(1,-1) + colocated(2,-1) + colocated(3,-1)
    pred[:,:] = s >> 2

  def DC_c(pred, colocated):
    s = 2
    for i in range(4):
      s += colocated(-1,0) + colocated(-1,1) + colocated(-1,2) + colocated(-1,3)
    pred[:,:] = s >> 2

  def DC_d(pred, bit_depth):
    pred[:,:] = 1 << (bit_depth - 1)

  def diag_down_left(pred, colocated):
    for y in range(4):
      for x in range(4):
        if y == 3 and x == 3:
          pred[3,3] = (colocated(-1,6) + 3 * colocated(-1,7) + 2) >> 2
        else:
          pred[y,x] = (colocated(-1,x+y) + 2 * colocated(-1,x+y+1) + colocated(-1,x+y+2) + 2) >> 2

  def diag_down_right(pred, colocated):
    for y in range(4):
      for x in range(4):
        if x > y:
          pred[y,x] = (colocated(-1,x-y-2) + 2*colocated(-2,x-y-1) + colocated(-1,x-y) + 2) >> 2
        elif x < y:
          pred[y,x] = (colocated(y-x-2,-1) + 2*colocated(y-x-1,-1) + colocated(y-x,-1) + 2) >> 2
        else:
          pred[y,x] = (colocated(-1,0) + 2 * colocated(-1,-1) + colocated(0,-1) + 2) >> 2

  def vertical_right(pred, colocated):
    for y in range(4):
      for x in range(4):
        zVR = 2 * x - y
        if zVR == -1:
          pred[y,x] = (colocated(0,-1) + 2 * colocated(-1,-1) + colocated(-1,0) + 2) >> 2
        elif zVR == -2 or zVR == -3:
          pred[y,x] = (colocated(y-1,-1) + 2*colocated(y-2,-1) + colocated(y-3,-1) + 2) >> 2
        elif zVR % 2 == 0:
          pred[y,x] = (colocated(-1,x-(y>>1)-1) + colocated(-1, x-(y>>1)) + 1) >> 1
        else:
          pred[y,x] = (colocated(-1,x-(y>>1)-2,-1) + 2*colocated(-1,x-(y>>1)-1) + colocated(-1,x-(y>>1))) >> 2

  def horizontal_down(pred, colocated):
    for y in range(4):
      for x in range(4):
        zHD = 2 * y - x
        if zHD == -1:
          pred[y,x] = (colocated(y-(x>>1),-1) + 2*colocated(y-(x>>1),-1) + colocated(y-(x>>1),-1) + 1) >> 1
        elif zHD == -2 or zHD == -3:
          pred[y,x] = (colocated(-1,x-1) + 2 * colocated(-1,x-2) + colocated(-1,x-3) + 2) >> 2
        elif zHD % 2 == 0:
          pred[y,x] = (colocated(y-(x>>1),-1) + colocated(y-(x>>1),-1) + 1) >> 1
        else:
          pred[y,x] = (colocated(y-(x>>1)-2,-1) + colocated(y-(x>>1)-1,-1) + colocated(y-(x>>1),-1) + 2) >> 2

  def vertical_left(pred, colocated):
    for y in range(4):
      for x in range(4): 
        if y == 0 or y == 2:
          pred[y,x] = (colocated(-1,x+(y>>1)) + colocated(-1,x+(y>>1)+1) + 1) >> 1
        else:
          pred[y,x] = (colocated(-1,x+(y>>1)) + 2*colocated(-1,x+(y>>1)+1) + colocated(-1,x+(y>>1)+2) + 2) >> 1

  def horizontal_up(pred, colocated):
    for y in range(4):
      for x in range(4):
        zHU = x + 2 * y
        if zHU > 5:
          pred[y,x] = colocated(3,-1)
        elif zHU == 5:
          pred[y,x] = (colocated(2,-1) + 3*colocated(3,-1) + 2) >> 2
        elif zHU == 1 or zHU == 3:
          pred[y,x] = (colocated(y+(x>>1),-1) + 2*colocated(y+(x>>1)+1,-1) + colocated(y+(x>>1)+2,-1) + 2) >> 2
        else:
          pred[y,x] = (colocated(y+(x>>1),-1) + colocated(y+(x>>1)+1,-1) + 1) >> 2

class H264IntraChroma:

  def schedule_chroma[E,T,C](to_pred_Cb_region: View[E,T,C], to_pred_Cr_region: View[E,T,C], ref_Cb_region, \
                             ref_Cr_region, intra_pred_info, intra_pred_mode_info, mb_type_info, pred_info, \
                             constrained_intra_pred_flag, bit_depth_C):
    """
    Predict chroma Cb and Cr. If chroma_array_type == 3, I believe they should be 16x16 macroblocks (so no downsampling).
    @ARG(to_pred_Cb_region, TO_PRED)
    @ARG(to_pred_Cr_region, TO_PRED)
    @ARG(ref_Cb_region, REF_REGION)
    @ARG(ref_Cr_region, REF_REGION)
    @ARG(intra_pred_info, INTRA_PRED_INFO)
    @ARG(intra_pred_mode_info, INTRA_PRED_MODE_INFO)
    @ARG(mb_type_info, MB_TYPE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)    
    @ARG(bit_depth_C)
    """
    colocated_Cb = ref_Cb_region[to_pred_Cb_region]
    colocated_Cr = ref_Cr_region[to_pred_Cr_region]
    # only need to run this once since Cb and Cr have same parameterizations
    # It's also the same as 16x16, ehnce calling it
    left,up,up_left = H264Intra16x16.check_availability(to_pred_Cb_region, colocated_Cb, mb_type_info, \
                                                        pred_info, constrained_intra_pred_flag)    
    preds_Cb = Array[Optional[Block[E,T,C]]](4)
    preds_Cr = Array[Optional[Block[E,T,C]]](4)
    # DC
    preds_Cb[0] = Block(to_pred_Cb_region)
    preds_Cr[0] = Block(to_pred_Cr_region)
    # vertical
    preds_Cb[1] = None
    preds_Cr[1] = None
    # horizontal
    preds_Cb[2] = None
    preds_Cr[2] = None
    # planar
    preds_Cb[3] = None
    preds_Cr[3] = None
    if up:
      preds_Cb[1] = Block(to_pred_Cb_region)
      preds_Cr[1] = Block(to_pred_Cr_region)
      H264Intra16x16.vertical(preds_Cb[1], colocated_Cb)
      H264Intra16x16.vertical(preds_Cr[1], colocated_Cr)
    if left:
      preds_Cb[2] = Block(to_pred_Cb_region)
      preds_Cr[2] = Block(to_pred_Cr_region)
      H264Intra16x16.horizontal(preds_Cb[2], colocated_Cb)
      H264Intra16x16.horizontal(preds_Cr[2], colocated_Cr)      
    # TODO left off here. Not enough energy to do the rest of the chroma stuff. Also, seems like the standard has some
    # superfluous references to chroma_array_type

  def schedule_chroma_array_type_3(to_pred_Cb_region, to_pred_Cr_region, ref_Cb_region, ref_Cr_region, intra_pred_info, \
                                   intra_pred_mode_info, pred_info, constrained_intra_pred_flag, bit_depth_C):
    """
    Predict 16x16 chroma according to clause 8.3.4.5.
    @ARG(to_pred_Cb_region, TO_PRED)
    @ARG(to_pred_Cr_region, TO_PRED)
    @ARG(ref_Cb_region, REF_REGION)
    @ARG(ref_Cr_region, REF_REGION)
    @ARG(intra_pred_info, INTRA_PRED_INFO)
    @ARG(intra_pred_mode_info, INTRA_PRED_MODE_INFO)
    @ARG(pred_info, PRED_INFO)
    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
    @ARG(bit_depth_C)
    """
    # only need to do this once since cb and cr share same structure
    intra = intra_pred_info(to_pred_Cb_region["macroblock"])
    colocated_Cb = ref_Cb_region[to_pred_Cb_region]
    colocated_Cr = ref_Cr_region[to_pred_Cr_region]
    # create blocks to hold the resulting predictions
    pred_Cb = Block(to_pred_Cb_region)
    pred_Cr = Block(to_pred_Cb_region)
    if intra == INTRA_4x4:
      # partition the prediction region into 4x4 subblocks and predict each using the corresponding mode used
      # for luma
      Cb_tree = Partition.grid(colocated_Cb, 4)[0]
      Cr_tree = Partition.grid(colocated_Cr, 4)[0]
      for Cb,Cr in scan(Cb_tree, Cr_tree):
        mode = intra_pred_mode_info(Cb)
        if mode == 0:
          H264Intra4x4.vertical(pred_Cb[Cb], Cb)
          H264Intra4x4.vertical(pred_Cr[Cr], Cr)
        elif mode == 1:
          H264Intra4x4.horizontal(pred_Cb[Cb], Cb)
          H264Intra4x4.horizontal(pred_Cr[Cr], Cr)          
        elif mode == 2:
          H264Intra4x4.DC_a(pred_Cb[Cb], Cb)
          H264Intra4x4.DC_a(pred_Cr[Cr], Cr)
        elif mode == 3:
          H264Intra4x4.DC_b(pred_Cb[Cb], Cb)
          H264Intra4x4.DC_b(pred_Cr[Cr], Cr)          
        elif mode == 4:
          H264Intra4x4.DC_c(pred_Cb[Cb], Cb)
          H264Intra4x4.DC_c(pred_Cr[Cr], Cr)          
        elif mode == 5:
          H264Intra4x4.DC_d(pred_Cb[Cb], bit_depth_C)
          H264Intra4x4.DC_d(pred_Cr[Cr], bit_depth_C)
        elif mode == 6:
          H264Intra4x4.diag_down_left(pred_Cb[Cb], Cb)
          H264Intra4x4.diag_down_left(pred_Cr[Cr], Cr)
        elif mode == 7:
          H264Intra4x4.diag_down_right(pred_Cb[Cb], Cb)
          H264Intra4x4.diag_down_right(pred_Cr[Cr], Cr)
        elif mode == 8:
          H264Intra4x4.vertical_right(pred_Cb[Cb], Cb)
          H264Intra4x4.vertical_right(pred_Cr[Cr], Cr)
        elif mode == 9:
          H264Intra4x4.horizontal_down(pred_Cb[Cb], Cb)
          H264Intra4x4.horizontal_down(pred_Cr[Cr], Cr)          
        elif mode == 10:
          H264Intra4x4.vertical_left(pred_Cb[Cb], Cb)
          H264Intra4x4.vertical_left(pred_Cr[Cr], Cr)
        else:
          H264Intra4x4.horizontal_up(pred_Cb[Cb], Cb)
          H264Intra4x4.horizontal_up(pred_Cr[Cr], Cr)
    elif intra == INTRA_8x8:
      # partition the prediction region into 8x8 subblocks and predict each using the corresponding mode used
      # for luma
      Cb_tree = Partition.grid(colocated_Cb, 8)[0]
      Cr_tree = Partition.grid(colocated_Cr, 8)[0]
      for Cb,Cr in scan(Cb_tree, Cr_tree):
        # first, we need to reference filter
        left,up_left,up,up_right = H264Intra8x8.check_availability(to_pred_Cb_region, colocated_Cb, pred_info, constrained_intra_pred_flag)
        filt_row_Cb,filt_col_Cb,up_right2 = H264Intra8x8.low_pass_filter(Cb, up, left, up_right, up_left)
        filt_row_Cr,filt_col_Cr,up_right2 = H264Intra8x8.low_pass_filter(Cr, up, left, up_right, up_left)
        up_right = up_right2
        mode = intra_pred_mode_info(Cb)
        if mode == 0:
          H264Intra8x8.vertical(pred_Cb[Cb], filt_row_Cb)
          H264Intra8x8.vertical(pred_Cr[Cr], filt_row_Cr)
        elif mode == 1:
          H264Intra8x8.horizontal(pred_Cb[Cb], filt_col_Cb)
          H264Intra8x8.horizontal(pred_Cr[Cr], filt_col_Cr)
        elif mode == 2:
          H264Intra8x8.DC_a(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
          H264Intra8x8.DC_a(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
        elif mode == 3:
          H264Intra8x8.DC_b(pred_Cb[Cb], filt_col_Cb)
          H264Intra8x8.DC_b(pred_Cr[Cr], filt_col_Cr)
        elif mode == 4:
          H264Intra8x8.DC_c(pred_Cb[Cb], filt_row_Cb)
          H264Intra8x8.DC_c(pred_Cr[Cr], filt_row_Cr)
        elif mode == 5:
          H264Intra8x8.DC_d(pred_Cb[Cb], bit_depth_C)
          H264Intra8x8.DC_d(pred_Cr[Cr], bit_depth_C)
        elif mode == 6:
          H264Intra8x8.diag_down_left(pred_Cb[Cb], filt_row_Cb)
          H264Intra8x8.diag_down_left(pred_Cr[Cr], filt_row_Cr)
        elif mode == 7:
          H264Intra8x8.diag_down_right(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
          H264Intra8x8.diag_down_right(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
        elif mode == 8:
          H264Intra8x8.vertical_right(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
          H264Intra8x8.vertical_right(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
        elif mode == 9:
          H264Intra8x8.horizontal_down(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
          H264Intra8x8.horizontal_down(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
        elif mode == 10:
          H264Intra8x8.vertical_left(pred_Cb[Cb], filt_row_Cb)
          H264Intra8x8.vertical_left(pred_Cr[Cr], filt_col_Cr)
        else:
          H264Intra8x8.horizontal_up(pred_Cb[Cb], filt_col_Cb)
          H264Intra8x8.horizontal_up(pred_Cr[Cr], filt_col_Cr)
    else:
      mode = intra_pred_mode_info(colocated_Cb)
      if mode == 0:
        H264Intra16x16.vertical(pred_Cb, colocated_Cb)
        H264Intra16x16.vertical(pred_Cr, colocated_Cr)
      elif mode == 1:
        H264Intra16x16.horizontal(pred_Cb, colocated_Cb)
        H264Intra16x16.horizontal(pred_Cr, colocated_Cr)    
      elif mode == 2:
        H264Intra16x16.DC_a(pred_Cb, colocated_Cb)
        H264Intra16x16.DC_a(pred_Cr, colocated_Cr)
      elif mode == 3:
        H264Intra16x16.DC_b(pred_Cb, colocated_Cb)
        H264Intra16x16.DC_b(pred_Cr, colocated_Cr)
      elif mode == 4:
        H264Intra16x16.DC_c(pred_Cb, colocated_Cb)
        H264Intra16x16.DC_c(pred_Cr, colocated_Cr)
      elif mode == 5:
        H264Intra16x16.DC_d(pred_Cb, bit_depth_C)
        H264Intra16x16.DC_d(pred_Cr, bit_depth_C)
      elif mode == 6:
        H264Intra16x16.DC_d(pred_Cb, colocated_Cb, bit_depth_C)
        H264Intra16x16.DC_d(pred_Cr, colocated_Cr, bit_depth_C)    
    return pred_Cb, pred_Cr       
