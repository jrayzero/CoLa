from ..cola.frontend.scan import *
from ..cola.frontend.constants import *
from intra import *
from constants import *
from cost import *
from transforms import *
from quantize import *
from config import *


  # TODO For 8x8 and 4x4, you couldn't do this in parallel b/c they'd both be overwriting the reconstruction frame.
  # Make it so you copy out the part you need and then just use that as the reference (same with pred info and mb type)

class FullRDO:

  """
  Tools for doing full rate-distortion optimized mode selection. This is very computationally expensive.
  """

  def score_modes(blk, pred_modes, lambda_val):
    """
    Generic function to run all the modes on the sub-blocks of a pred region.
    """
    best_local_pred = pred_modes[0]
    best_local_mode = 0
    best_local_cost = MAX_FLOAT_32
    best_local_recons = pred_modes[0]
    for idx,pred in enumerate(pred_modes):
      # TODO how to select "most probable mode"?
      cost = FullRDO.rate_decision_A(blk, pred, lambda_val, idx == 2)
      if cost < best_local_cost:
        best_local_cost = cost
        best_local_mode = idx
        # TODO FOR NOW, USING PRED AS RECONS
        best_local_recons = pred 
        best_local_pred = pred
    return best_local_pred, best_local_mode, best_local_cost, best_local_recons        

  def schedule(Y_mb, Y_recons, Cb_mb, Cb_recons, Cr_mb, Cr_recons, mb_type_info, \
               pred_info, constrained_intra_pred_flag, bit_depth, lambda_val):
    """
    Do full RDO for mode selection. This is the main control function.
    """    
    
    ### 16x16 ###
    # do the prediction for each mode
    preds_16x16 = H264Intra16x16.schedule_luma(Y_mb, Y_recons, mb_type_info, \
                                               pred_info, constrained_intra_pred_flag, bit_depth)
    best_pred,best_mode,best_cost,best_recons = FullRDO.score_modes(Y_mb, preds_16x16, lambda_val)
    print 'best 16x16 mode for region at ' + str(Y_mb.origin_relative_to(Y_recons)) + ' is ' + \
      str(best_mode) + ' with cost ' + str(best_cost)

    residual = int(Y_mb) - best_pred
    # handle the main 4x4 blocks within the 16x16
    reconstruction = Block(residual)
    quantized = Block(residual)
    coeffs = Block(residual)
    res_split,coeffs_split,quant_split,recons_split = Partition.grid(residual,4), \
                                                      Partition.grid(coeffs,4), \
                                                      Partition.grid(quantized,4), \
                                                      Partition.grid(reconstruction,4)
    for res_4x4,coeff_4x4,quant_4x4,recons_4x4 in scan(res_split, coeffs_split, quant_split, recons_split):
      DCT.dct4x4(res_4x4,coeff_4x4) # keep the coeffs separate since need for the DCs later=
      H264Quantize4x4.quantize(coeff_4x4, quant_4x4, QP)
      DCT.idct4x4(H264Quantize4x4.dequantize(quant_4x4, QP), recons_4x4)      
      recons_4x4 >>= 6

    # DC transform and quantization
    # Hmm, this seems to be calculating fine, but it gives a higher dynamic range of quant values...
    DC_coeffs = Hadamard.hadamard4x4(coeffs[::4,::4])
    H264Quantize4x4.quantize(DC_coeffs, quantized[::4,::4], QP)
    # inverse
    Hadamard.ihadamard4x4(H264Quantize4x4.dequantize(quantized[::4,::4], QP), reconstruction[::4,::4])
    reconstruction[::4,::4] >>= 6
    
    # Entropy code it  

# TODO Uncomment once get the whole pipeline functioning for 16x16
#    ### 8x8 ###
#    Y_8x8s = Partition.grid(Y_mb, 8)[0]
#    # locally build up the mb reconstruction from the 8x8 subblocks
#    Y_8x8_recons = Y_mb.shallow_cast[int]()
#    Y_8x8_pred = Y_mb.shallow_cast[int]() # fill in this with the best pred for each 8x8 section
#    for y in scan(Y_8x8s): # y is an 8x8 block
#      preds_8x8 = H264Intra8x8.schedule_luma(y, Y_recons, pred_info, \
#                                             constrained_intra_pred_flag, bit_depth)
#      best_local_pred,best_local_mode,best_local_cost,best_local_recons = FullRDO.score_modes(y, preds_8x8)
#      print 'best 8x8 mode for region at ' + str(y.origin_relative_to(Y_mb)) + ' is ' + str(best_local_mode) + \
#        ' with cost ' + str(best_local_cost) + ' (' + str(y.origin_relative_to(Y_recons)) + ')' 
#      Y_8x8_recons[y] = ~best_local_recons
#      Y_8x8_pred[y] = ~best_local_pred
#    # now see if the whole prediction is better than the curren one
#    # just use a straight SAD here
#    cost = FullRDO.rate_decision_A(Y_mb, Y_8x8_pred, lambda_val, True) # pretend that for this, we #consider 8x8 to be the mode and it is most probable
#    if cost < best_cost:
#      best_cost = cost
#      best_sz = INTRA_8x8
#      best_recons = Y_8x8_recons
#      best_pred = Y_8x8_pred
#
#    ### 4x4 ###
#    Y_4x4s = Partition.grid(Y_mb, 4)[0]
#    # locally build up the mb reconstruction from the 4x4 subblocks
#    Y_4x4_recons = Y_mb.shallow_cast[int]()
#    Y_4x4_pred = Y_mb.shallow_cast[int]() # fill in this with the best pred for each 4x4 section
#    for y in scan(Y_4x4s): # y is an 4x4 block
#      y["macroblock"] = Y_mb
#      preds_4x4 = H264Intra4x4.schedule_luma(y, Y_recons, mb_type_info, pred_info, \
#                                             constrained_intra_pred_flag, bit_depth)
#      best_local_pred,best_local_mode,best_local_cost,best_local_recons = FullRDO.score_modes(y, preds_4x4)
#      print 'best 4x4 mode for region at ' + str(y.origin_relative_to(Y_mb)) + ' is ' + str(best_local_mode) + \
#        ' with cost ' + str(best_local_cost) + ' (' + str(y.origin_relative_to(Y_recons)) + ')' 
#      Y_4x4_recons[y] = ~best_local_recons
#      Y_4x4_pred[y] = ~best_local_pred
#
#    # now see if the whole prediction is better than the current one
#    # just use a straight SAD here
#    cost = FullRDO.rate_decision_A(Y_mb, Y_4x4_pred, lambda_val, True) # pretend that for this, we consider 4x4 to be the mode and it is most probable
#    if cost < best_cost:
#      best_cost = cost
#      best_sz = INTRA_4x4
#      best_recons = Y_4x4_recons
#      best_pred = Y_4x4_pred
#      
    ### Finalize ###

#    print 'Best size ' + str(int_to_intra(best_sz)) + ' for mb ' + str(Y_mb.origin())
#    # Set the status of the macroblock to intra. We don't need to set it for the individual 8x8 and 4x4 partitions 
#    # because intra-pred applies to the whole macroblock.
#    pred_info[Y_mb] = True
#    # write the best stuff
#    assert best_recons
#    Y_recons[Y_mb] = ~best_recons
#
#    # the residual is used for the rest of the pipeline
#    residual = Y_mb - best_pred
#    print residual
#    return residual

  # TODO use rate decision as J = D + λR, where D is the distortion metric and R is the number of bits used for encoding
      
  def rate_decision_A[T](orig, _pred: Optional[T], lambda_val: float, P: bool) -> float:
    """
    Computes JSAD = SAD + λ * 4P, where SAD is between the original and the prediction and P == 0
    for the most probable mode.
    https://link.springer.com/content/pdf/10.1007/s11760-011-0267-z.pdf
    JM 12.4
    """
    if not _pred:
      return MAX_FLOAT_32
    else:
      return FullRDO.rate_decision_A(orig, ~_pred, lambda_val, P)
    
  def rate_decision_A(orig, pred, lambda_val: float, P: bool) -> float:
    """
    Computes JSAD = SAD + λ * 4P, where SAD is between the original and the prediction and P == 0
    for the most probable mode.
    https://link.springer.com/content/pdf/10.1007/s11760-011-0267-z.pdf
    JM 12.4
    """
    cost = Cost.sad(orig, pred) + lambda_val * 4.0 * float(P)
    return cost
    

