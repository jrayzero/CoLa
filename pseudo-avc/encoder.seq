from ..cola.frontend.block import *
from ..cola.frontend.error import *
from ..cola.frontend.scan import *
from ..cola.frontend.flagtree import *

from basic_io import *
from constants import *
from partition import *
from intra import *
from config import *
from structures import *
from trav import *
from transforms import *
from quantize import *
from cost import *
from parameter_sets import *
from syntax import *

# TODO NOTE: deblocking used only for inter-prediction (but you would still filter the intra-predicted mbs).
#  This means we need to store both filtered and unfiltered references

import sys

if len(sys.argv) < 2:
  raise ColaError()

config_file = sys.argv[1]
cfg = Config(config_file)

ifd = open(cfg.input_file, 'rb')
ofd = open(cfg.output_file, 'wb')

lframe_w,lframe_h = cfg.lframe_width_in_pixels, cfg.lframe_height_in_pixels
cframe_w,cframe_h = cfg.cframe_width_in_pixels, cfg.cframe_height_in_pixels

# holds the raw pixels
Y_frame = Block.make[byte](lframe_h, lframe_w)
Cb_frame = Block.make[byte](cframe_h, cframe_w)
Cr_frame = Block.make[byte](cframe_h, cframe_w)

# These hold the (unfiltered) reconstructed values
Y_recons = Y_frame.shallow_cast[int]()
Cb_recons = Cb_frame.shallow_cast[int]()
Cr_recons = Cr_frame.shallow_cast[int]()

# have deblocking filtered applied before reconstruction (for inter)
Y_recons_filt = Y_frame.shallow_cast[int]()
Cb_recons_filt = Cb_frame.shallow_cast[int]()
Cr_recons_filt = Cr_frame.shallow_cast[int]()

# for inter-prediction, we need our reference pixels with the loop filter applied

# buffer for the final encoding
enc = Bits[64]()

# Set up some initial syntax to write out
sps = SPS()
sps.profile_idc = 66
sps.level_idc = 62 # just set it high so we don't have to worry about it
sps.seq_parameter_set_id = 0
sps.pic_height_in_map_units_minus1 = Y_frame.dims()[0] // 16 - 1
sps.pic_width_in_mbs_minus1 = Y_frame.dims()[1] // 16 - 1

pps = PPS()
pps.pic_parameter_set_id = 0
pps.seq_parameter_set_id = 0
pps.num_ref_idx_l0_default_active_minus1 = 4
pps.num_ref_idx_l1_default_active_minus1 = 4

Syntax.write_sps(sps, enc)
Syntax.write_pps(pps, enc)

# main loop
for f in range(cfg.nframes):
  if cfg.color_space == YUV:
    read_frame(Y_frame, Cb_frame, Cr_frame, ifd, cfg)
  # Initial partition of the frames into macroblocks
  Y_mbs = Partition.grid(Y_frame, 16)
  Cb_mbs = Partition.grid(Cb_frame, 8)
  Cr_mbs = Partition.grid(Cr_frame, 8)
  Y_rmbs = Partition.grid(Y_recons, 16)
  Cb_rmbs = Partition.grid(Cb_recons, 8)
  Cr_rmbs = Partition.grid(Cr_recons, 8)
  # don't pass in MblkInfo() because it will set all of the nodes to the same mblk, so then they are all just pointers to one another
  # TODO yikes this notation
  mblk_info = Y_mbs.to_flagtree[MblkInfo[Tuple[ColaSlice,ColaSlice]]]()
  cur_slice_id = 0
  mbs_in_slice = 0
  write_slice_header = True
  mb_idx = 0
  for Y_mb,Y_rmb in scan(Y_mbs, Y_rmbs):
    if write_slice_header:
      sh = SliceHeader()
      sh.first_mb_in_slice = mb_idx
      sh.slice_type = I_SLICE_ALL
      sh.pic_parameter_set_id = 0
      sh.frame_num = f
      sh.idr_pic_id = 0
      Syntax.write_slice_header(sh, sps, pps, enc)
      Syntax.write_slice_data_preamble(pps, enc)
    write_slice_header = False
    mblk_info[Y_mb].slice_id = cur_slice_id
    # Intra prediction
    cost_16x16,mode_16x16,DCs_16x16,quant_16x16,local_recons_16x16_unfilt = \
      IntraPred.try_16x16(Y_mb, Y_rmb, mblk_info, cfg)
    # returns the full cost + full 16x16 pred (made of 4x4 blocks)
    cost_4x4,mode_tree_4x4,quant_4x4,local_recons_4x4_unfilt = \
      IntraPred.try_4x4(Y_mb, Y_rmb, mblk_info, cfg)
    mblk_info[Y_mb].is_intra_pred = True
    if cost_16x16 <= cost_4x4:
      Y_recons[local_recons_16x16_unfilt] = local_recons_16x16_unfilt
      # TODO entropy code everything (from DCs and quant)
    else:
      Y_recons[local_recons_4x4_unfilt] = local_recons_4x4_unfilt
      # TODO entropy code everything (from quant)
    # update slice status
    mbs_in_slice += 1
    if cfg.macroblocks_per_slice != -1 and cfg.macroblocks_per_slice == mbs_in_slice:
      mbs_in_slice = 0
      cur_slice_id += 1
      write_slice_header = True
    mb_idx += 1

print(enc)

ifd.close()
ofd.flush()
ofd.close()
