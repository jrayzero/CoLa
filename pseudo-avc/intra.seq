from ..cola.frontend.block import *
from ..cola.frontend.scan import scan
from ..cola.frontend.flagtree import *
from ..cola.frontend.constants import MAX_INT_32
from partition import *
from utils import *
from constants import *
from cost import *
from structures import *
from transforms import *
from quantize import *

class IntraPred:

  def try_mode(data, recons, cur_best_cost, cur_best_mode, cur_best_pred, mode_id, mode_func, *args):
    pred = data.shallow_cast[int]()
    mode_func(pred, recons[pred], *args)
    cost = Cost.sad(data, pred)
    if cost < cur_best_cost:
      return cost, mode_id, Optional(pred)
    else:
      return cur_best_cost, cur_best_mode, cur_best_pred

  # Availability means: data exists (wrt bounds and traversal order within a partition) and has the same slice. The traversal order
  # part is currently satisfied by checking the mode id in mode_tree. If it is -1, that block hasn't been predicted
  # yet. But this isn't very generalizable able (see todo)
  # TODO need to be able to check existence wrt a traversal order within a partition

  def left_available(blk, blk_info, mode_tree: Optional[FlagTree[Tuple[ColaSlice,ColaSlice],BlkInfo]]=None):
    available_wrt_part_order = not mode_tree or (
          mode_tree.exists(blk[0, -1]) and mode_tree[blk[0, -1]].mode != UNKNOWN_MODE)
    if blk[0,-1].exists() and available_wrt_part_order:
      my_sid = blk_info[blk[0,0]].slice_id
      left_sid = blk_info[blk[0,-1]].slice_id
      if my_sid == left_sid:
        return True
    return False

  def up_available(blk, blk_info, mode_tree: Optional[FlagTree[Tuple[ColaSlice,ColaSlice],BlkInfo]]=None):
    available_wrt_part_order = not mode_tree or (
          mode_tree.exists(blk[-1,0]) and mode_tree[blk[-1,0]].mode != UNKNOWN_MODE)
    if blk[-1,0].exists() and available_wrt_part_order:
      my_sid = blk_info[blk[0,0]].slice_id
      up_sid = blk_info[blk[-1,0]].slice_id
      if my_sid == up_sid:
        return True
    return False

  def up_left_available(blk, blk_info, mode_tree: Optional[FlagTree[Tuple[ColaSlice,ColaSlice],BlkInfo]]=None):
    available_wrt_part_order = not mode_tree or (
          mode_tree.exists(blk[-1,-1]) and mode_tree[blk[-1,-1]].mode != UNKNOWN_MODE)
    if blk[-1,-1].exists() and available_wrt_part_order:
      my_sid = blk_info[blk[0,0]].slice_id
      up_left_sid = blk_info[blk[-1,-1]].slice_id
      if my_sid == up_left_sid:
        return True
    return False
      
  def up_right_available(blk, blk_info, mode_tree: Optional[FlagTree[Tuple[ColaSlice,ColaSlice],BlkInfo]]=None):
    available_wrt_part_order = not mode_tree or (
          mode_tree.exists(blk[-1,blk.dims()[1]+1]) and mode_tree[blk[-1,blk.dims()[1]+1]].mode != UNKNOWN_MODE)
    if blk[-1,blk.dims()[1]+1].exists() and available_wrt_part_order:
      my_sid = blk_info[blk[0,0]].slice_id
      up_right_sid = blk_info[blk[-1,blk.dims()[1]+1]].slice_id
      if my_sid == up_right_sid:
        return True
    return False

  def try_16x16(Y_mb, Y_rmb, blk_info, cfg):
    left,up,up_left = IntraPred.left_available(Y_mb, blk_info),\
                      IntraPred.up_available(Y_mb, blk_info),\
                      IntraPred.up_left_available(Y_mb, blk_info)
    if cfg.trace:
      note('Y_MB: ' + str(Y_mb.dims()) + ' @ ' + str(Y_mb.origin()) + ' has left,up,up_left: ' + str(left) + ',' + str(
        up) + ',' + str(up_left))
    best_cost = MAX_INT
    best_pred = None
    best_mode = UNKNOWN_MODE
    local_Y_rmb = Block(Y_rmb)
    if left and not cfg.skip_16x16_horiz:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         HORIZ_16x16, IntraPred.horizontal_16x16)
    if up and not cfg.skip_16x16_vert:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         VERT_16x16, IntraPred.vertical_16x16)
    if up and left and not cfg.skip_16x16_planar:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         PLANAR_16x16, IntraPred.planar_16x16, cfg.bit_depth)
    # now try the DC modes (only try one of these)
    if up and left:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         DC_16x16, IntraPred.DC_a_16x16)
    elif left:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         DC_16x16, IntraPred.DC_b_16x16)
    elif up:
      best_cost,best_mode,best_pred = IntraPred.try_mode(Y_mb, local_Y_rmb, best_cost, best_mode, best_pred,
                                                         DC_16x16, IntraPred.DC_c_16x16)
    else:
      # need to store ints, not bytes
      pred = Y_mb.shallow_cast[int]()
      IntraPred.DC_d_16x16(pred, cfg.bit_depth)
      cost = Cost.sad(Y_mb, pred)
      if cost < best_cost:
        best_cost = cost
        best_pred = pred
        best_mode = DC_16x16
    residual = int(Y_mb) - best_pred
    residual.remap(Y_mb)  # need to set the cgrid
    xform_blks = Partition.grid(residual, 4)
    DCs = Block(residual[::4, ::4])
    quant = Block(residual)
    coeffs = Block(residual)
    coeff_blks = Partition.grid(coeffs, 4)
    quant_blks = Partition.grid(quant, 4)
    for resid, coeff_blk, qblk in scan(xform_blks, coeff_blks, quant_blks):
      DCT.dct4x4(resid, coeff_blk)
      # store the DCs for later
      val = coeff_blk(0)
      DCs[coeff_blk[0]] = val
      Quantize.quantize_4x4(coeff_blk, qblk, cfg.qp)
    Hadamard.hadamard4x4(DCs, DCs)
    Quantize.quantize_4x4(DCs, DCs, cfg.qp)
    # now reconstruction
    Hadamard.ihadamard4x4(DCs, coeffs[::4, ::4])
    coeff_blks = Partition.grid(coeffs, 4)
    for cblk, qblk in scan(coeff_blks, quant_blks):
      Quantize.dequantize_4x4(qblk, cblk, cfg.qp)
      DCT.idct4x4(cblk, cblk)
      cblk >>= 6
    # coeffs now contains the reconstruction of the residual
    local_Y_rmb[coeffs] = coeffs + best_pred
    if cfg.trace:
      note('Y_MB: ' + str(Y_mb.dims()) + ' @ ' + str(Y_mb.origin()) + ' has cost ' + str(best_cost) + ' for mode ' + mode_16x16_to_str(best_mode))
    return best_cost,best_mode,DCs,quant,local_Y_rmb

  def vertical_16x16(pred, ref_colocated):
    for i in range(pred.dims()[0]):
      pred[:,i] = int(ref_colocated(-1,i))

  def horizontal_16x16(pred, ref_colocated):
    for i in range(pred.dims()[0]):
      pred[i,:] = int(ref_colocated(i,-1))

  def DC_a_16x16(pred, ref_colocated):
    s = 16
    for i in range(pred.dims()[0]):
      s += int(ref_colocated(-1,i)) + int(ref_colocated(i,-1))
    s >>= 5    
    pred[:,:] = s

  def DC_b_16x16(pred, ref_colocated):
    s = 8
    for i in range(pred.dims()[0]):
      s += int(ref_colocated(i,-1))
    s >>= 4
    pred[:,:] = s

  def DC_c_16x16(pred, ref_colocated):
    s = 8
    for i in range(pred.dims()[0]):
      s += int(ref_colocated(-1,i))
    s >>= 4
    pred[:,:] = s

  def DC_d_16x16(pred, bit_depth):
    pred[:,:] = 1 << (bit_depth - 1)

  def planar_16x16(pred, ref_colocated, bit_depth):
    H = 0
    V = 0
    for i in range(8):
      H += (i+1) * (int(ref_colocated(-1,8+i))-int(ref_colocated(-1,i)))   
      V += (i+1) * (int(ref_colocated(8+i,-1))-int(ref_colocated(i,-1)))
    a = 16 * (int(ref_colocated(15,-1))+int(ref_colocated(-1,15)))
    b = (5 * H + 32) >> 6
    c = (5 * V + 32) >> 6
    for y in range(16):
      for x in range(16):
        clip_val = (a + b * (x - 7) + c * (y - 7) + 16) >> 5
        pred[y,x] = (clip1y(clip_val, bit_depth))

  def try_4x4(Y_mb, Y_rmb, blk_info, cfg):
    # store best mode for each of the 16 4x4 blocks
    best_costs = [MAX_INT] * 16
    full_pred = Y_mb.shallow_cast[int]()
    Y_4x4 = Partition.grid_quadtree(Y_mb, 2)[0]
    mode_tree = Y_4x4.to_flagtree[BlkInfo]()
    quant = Y_mb.shallow_cast[int]() # holds output of quantization
    idx = 0
    # setup the local reconstruction (not all of this data will necessarily be valid, but we make a big enough block
    # pretending that it all is)
    local_Y_recons = Block(Y_rmb[-1:,-1:20])
    local_Y_recons[:,:] = 0
    # check existence of Y_rmb instead of local_Y_recons since local_Y_recons has its own buffer so we would always be out
    if Y_rmb[-1,-1].exists():
      local_Y_recons[Y_rmb[-1,-1]] = Y_rmb[-1,-1]
    if Y_rmb[-1,0].exists():
      # row above
      local_Y_recons[Y_rmb[-1,:]] = Y_rmb[-1,:]
    if Y_rmb[0,-1].exists():
      # column left
      local_Y_recons[Y_rmb[:,-1]] = Y_rmb[:,-1]
    if Y_rmb[-1,16].exists(): # need this for the upper right 4x4 block if it accesses up to the right
      local_Y_recons[Y_rmb[-1,16:20]] = Y_rmb[-1,16:20]
    # re-pull out the appropriate location
    local_Y_rmb = local_Y_recons[Y_rmb]
    for y_4x4 in scan(Y_4x4):
      left, up, up_left, up_right = IntraPred.left_available(y_4x4, blk_info, mode_tree), \
                                    IntraPred.up_available(y_4x4, blk_info, mode_tree), \
                                    IntraPred.up_left_available(y_4x4, blk_info, mode_tree), \
                                    IntraPred.up_right_available(y_4x4, blk_info, mode_tree)
      local_best_pred = None
      local_best_mode = UNKNOWN_MODE
      if left:
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             HORIZ_4x4, IntraPred.horizontal_4x4)
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             HORIZ_UP_4x4, IntraPred.horizontal_up_4x4)
      if up:
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             VERT_4x4, IntraPred.vertical_4x4)
      if up and up_right:
        best_costs[idx], local_best_mode, local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             DIAG_DOWN_LEFT_4x4, IntraPred.diag_down_left_4x4)
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             VERT_LEFT_4x4, IntraPred.vertical_left_4x4)
      if up and left and up_left:
        pred = y_4x4.shallow_cast[int]()
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             DIAG_DOWN_RIGHT_4x4, IntraPred.diag_down_right_4x4)
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             VERT_RIGHT_4x4, IntraPred.vertical_right_4x4)
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             HORIZ_DOWN_4x4, IntraPred.horizontal_down_4x4)
      # now try one of the DC modes (can only use one)
      if up and left:
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             DC_4x4, IntraPred.DC_a_4x4)
      elif left:
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             DC_4x4, IntraPred.DC_b_4x4)
      elif up:
        best_costs[idx],local_best_mode,local_best_pred = \
          IntraPred.try_mode(y_4x4, local_Y_rmb, best_costs[idx], local_best_mode, local_best_pred,
                             DC_4x4, IntraPred.DC_c_4x4)
      else:
        # This one is different b/c the mode function takes a different argument
        pred = y_4x4.shallow_cast[int]()
        IntraPred.DC_d_4x4(pred, cfg.bit_depth)
        cost = Cost.sad(y_4x4, pred)
        if cost < best_costs[idx]:
          best_costs[idx] = cost
          local_best_pred = pred
          local_best_mode = DC_4x4
      if cfg.trace:
        note(
          'y_4x4: ' + str(y_4x4.dims()) + ' @ ' + str(y_4x4.origin()) + ' has cost ' + str(best_costs[idx]) + ' for mode ' + mode_4x4_to_str(local_best_mode))
      full_pred[~local_best_pred] = ~local_best_pred
      mode_tree[~local_best_pred].mode = local_best_mode
      idx += 1
      # at this point, we have the best mode. Now we need to run it through the rest of the pipeline
      # so we can create the local reconstruction for it>
      residual = int(y_4x4) - ~local_best_pred
      residual.remap(y_4x4)
      coeffs = Block(residual)
      # forward (save quantized coeffs for later entropy coding)
      DCT.dct4x4(residual, coeffs)
      Quantize.quantize_4x4_JM_normal(coeffs, quant[coeffs], cfg)
      # reconstruction
      local_Y_rmb[coeffs] = quant[coeffs]
      Quantize.dequantize_4x4_JM_normal(local_Y_rmb[coeffs], cfg)
      DCT.idct4x4(local_Y_rmb[coeffs], local_Y_rmb[coeffs])
      # 6=DQ_BITS
      # TODO elementwise min so don't need loop for this
      local_Y_rmb[coeffs] = Quantize.rshift_rnd_sf(local_Y_rmb[coeffs], 6) + ~local_best_pred
      for c in scan(local_Y_rmb[coeffs]):
        c[0] = min(c(), 255)
    # compute the total cost
    total_cost = 0
    for cost in best_costs:
      total_cost += cost
    mode_tree.flag.intra_pred_type = INTRA_4x4
    return total_cost,mode_tree,quant,local_Y_rmb

  def vertical_4x4(pred, ref_colocated):
    for i in range(4):
      pred[:,i] = int(ref_colocated(-1,i))

  def horizontal_4x4(pred, ref_colocated):
    for i in range(4):
      pred[i,:] = int(ref_colocated(i,-1))

  def DC_a_4x4(pred, ref_colocated):
    s = 4
    s += int(ref_colocated(-1,0)) + int(ref_colocated(-1,1)) + int(ref_colocated(-1,2)) + int(ref_colocated(-1,3))
    s += int(ref_colocated(0,-1)) + int(ref_colocated(1,-1)) + int(ref_colocated(2,-1)) + int(ref_colocated(3,-1))
    pred[:,:] = s >> 3

  def DC_b_4x4(pred, ref_colocated):
    s = 2 + int(ref_colocated(0,-1)) + int(ref_colocated(1,-1)) + int(ref_colocated(2,-1)) + int(ref_colocated(3,-1))
    pred[:,:] = s >> 2

  def DC_c_4x4(pred, ref_colocated):
    s = 2 + int(ref_colocated(-1,0)) + int(ref_colocated(-1,1)) + int(ref_colocated(-1,2)) + int(ref_colocated(-1,3))
    pred[:,:] = s >> 2

  def DC_d_4x4(pred, bit_depth):
    pred[:,:] = 1 << (bit_depth - 1)

  def diag_down_left_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        if y == 3 and x == 3:
          pred[3,3] = (int(ref_colocated(-1,6)) + 3 * int(ref_colocated(-1,7)) + 2) >> 2
        else:
          pred[y,x] = (int(ref_colocated(-1,x+y)) + 2 * int(ref_colocated(-1,x+y+1)) + int(ref_colocated(-1,x+y+2)) + 2) >> 2

  def diag_down_right_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        if x > y:
          pred[y,x] = (int(ref_colocated(-1,x-y-2)) + 2*int(ref_colocated(-1,x-y-1)) + int(ref_colocated(-1,x-y)) + 2) >> 2
        elif x < y:
          pred[y,x] = (int(ref_colocated(y-x-2,-1)) + 2*int(ref_colocated(y-x-1,-1)) + int(ref_colocated(y-x,-1)) + 2) >> 2
        else:
          pred[y,x] = (int(ref_colocated(-1,0)) + 2 * int(ref_colocated(-1,-1)) + int(ref_colocated(0,-1)) + 2) >> 2

  def vertical_right_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        zVR = 2 * x - y
        if zVR == -1:
          pred[y,x] = (int(ref_colocated(0,-1)) + 2 * int(ref_colocated(-1,-1)) + int(ref_colocated(-1,0)) + 2) >> 2
        elif zVR == -2 or zVR == -3:
          pred[y,x] = (int(ref_colocated(y-1,-1)) + 2*int(ref_colocated(y-2,-1)) + int(ref_colocated(y-3,-1)) + 2) >> 2
        elif zVR % 2 == 0:
          pred[y,x] = (int(ref_colocated(-1,x-(y>>1)-1)) + int(ref_colocated(-1, x-(y>>1))) + 1) >> 1
        else:
          pred[y,x] = (int(ref_colocated(-1,x-(y>>1)-2)) + 2*int(ref_colocated(-1,x-(y>>1)-1)) + int(ref_colocated(-1,x-(y>>1)))) >> 2

  def horizontal_down_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        zHD = 2 * y - x
        if zHD == -1:
          pred[y,x] = (int(ref_colocated(y-(x>>1),-1)) + 2*int(ref_colocated(y-(x>>1),-1)) + int(ref_colocated(y-(x>>1),-1)) + 1) >> 1
        elif zHD == -2 or zHD == -3:
          pred[y,x] = (int(ref_colocated(-1,x-1)) + 2 * int(ref_colocated(-1,x-2)) + int(ref_colocated(-1,x-3)) + 2) >> 2
        elif zHD % 2 == 0:
          pred[y,x] = (int(ref_colocated(y-(x>>1),-1)) + int(ref_colocated(y-(x>>1),-1)) + 1) >> 1
        else:
          pred[y,x] = (int(ref_colocated(y-(x>>1)-2,-1)) + int(ref_colocated(y-(x>>1)-1,-1)) + int(ref_colocated(y-(x>>1),-1)) + 2) >> 2

  def vertical_left_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        if y == 0 or y == 2:
          pred[y,x] = (int(ref_colocated(-1,x+(y>>1))) + int(ref_colocated(-1,x+(y>>1)+1)) + 1) >> 1
        else:
          pred[y,x] = (int(ref_colocated(-1,x+(y>>1))) + 2*int(ref_colocated(-1,x+(y>>1)+1)) + int(ref_colocated(-1,x+(y>>1)+2)) + 2) >> 1

  def horizontal_up_4x4(pred, ref_colocated):
    for y in range(4):
      for x in range(4):
        zHU = x + 2 * y
        if zHU > 5:
          pred[y,x] = int(ref_colocated(3,-1))
        elif zHU == 5:
          pred[y,x] = (int(ref_colocated(2,-1)) + 3*int(ref_colocated(3,-1)) + 2) >> 2
        elif zHU == 1 or zHU == 3:
          pred[y,x] = (int(ref_colocated(y+(x>>1),-1)) + 2*int(ref_colocated(y+(x>>1)+1,-1)) + int(ref_colocated(y+(x>>1)+2,-1)) + 2) >> 2
        else:
          pred[y,x] = (int(ref_colocated(y+(x>>1),-1)) + int(ref_colocated(y+(x>>1)+1,-1)) + 1) >> 1

#class H264IntraChroma:
#
#  def schedule_chroma[E,T,C](Cb_region_to_predict: View[E,T,C], to_pred_Cr_region: View[E,T,C], ref_Cb_region, \
#                             ref_Cr_region, intra_pred_info, intra_pred_mode_info, mb_type_info, pred_info, \
#                             constrained_intra_pred_flag, bit_depth_C):
#    """
#    Predict chroma Cb and Cr. If chroma_array_type == 3, I believe they should be 16x16 macroblocks (so no downsampling).
#    @ARG(Cb_region_to_predict, TO_PRED)
#    @ARG(to_pred_Cr_region, TO_PRED)
#    @ARG(ref_Cb_region, REF_REGION)
#    @ARG(ref_Cr_region, REF_REGION)
#    @ARG(intra_pred_info, INTRA_PRED_INFO)
#    @ARG(intra_pred_mode_info, INTRA_PRED_MODE_INFO)
#    @ARG(mb_type_info, MB_TYPE_INFO)
#    @ARG(pred_info, PRED_INFO)
#    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)    
#    @ARG(bit_depth_C)
#    """
#    ref_colocated_Cb = ref_Cb_region[Cb_region_to_predict]
#    ref_colocated_Cr = ref_Cr_region[to_pred_Cr_region]
#    # only need to run this once since Cb and Cr have same parameterizations
#    # It's also the same as 16x16, ehnce calling it
#    left,up,up_left = H264Intra16x16.check_availability(Cb_region_to_predict, ref_colocated_Cb, mb_type_info, \
#                                                        pred_info, constrained_intra_pred_flag)    
#    preds_Cb: list[Optional[Block[E,T,C]]] = [Block(Cb_region_to_predict), None, None, None]
#    preds_Cr: list[Optional[Block[E,T,C]]] = [Block(Cb_region_to_predict), None, None, None]
#    if up:
#      preds_Cb[1] = Block(Cb_region_to_predict)
#      preds_Cr[1] = Block(to_pred_Cr_region)
#      H264Intra16x16.vertical(preds_Cb[1], ref_colocated_Cb)
#      H264Intra16x16.vertical(preds_Cr[1], ref_colocated_Cr)
#    if left:
#      preds_Cb[2] = Block(Cb_region_to_predict)
#      preds_Cr[2] = Block(to_pred_Cr_region)
#      H264Intra16x16.horizontal(preds_Cb[2], ref_colocated_Cb)
#      H264Intra16x16.horizontal(preds_Cr[2], ref_colocated_Cr)      
#    # TODO left off here. Not enough energy to do the rest of the chroma stuff. Also, seems like the standard has some
#    # superfluous references to chroma_array_type
#
#  def schedule_chroma_array_type_3(Cb_region_to_predict, Cr_region_to_predict, ref_Cb_region, ref_Cr_region, intra_pred_info, \
#                                   intra_pred_mode_info, pred_info, constrained_intra_pred_flag, bit_depth_C):
#    """
#    Predict 16x16 chroma according to clause 8.3.4.5.
#    @ARG(Cb_region_to_predict, TO_PRED)
#    @ARG(Cr_region_to_predict, TO_PRED)
#    @ARG(ref_Cb_region, REF_REGION)
#    @ARG(ref_Cr_region, REF_REGION)
#    @ARG(intra_pred_info, INTRA_PRED_INFO)
#    @ARG(intra_pred_mode_info, INTRA_PRED_MODE_INFO)
#    @ARG(pred_info, PRED_INFO)
#    @ARG(constrained_intra_pred_flag, CONSTRAINED_INTRA_PRED_FLAG)
#    @ARG(bit_depth_C)
#    """
#    # only need to do this once since cb and cr share same structure
#    intra = intra_pred_info[Cb_region_to_predict["macroblock"]]
#    ref_colocated_Cb = ref_Cb_region[Cb_region_to_predict]
#    ref_colocated_Cr = ref_Cr_region[Cr_region_to_predict]
#    # create blocks to hold the resulting predictions
#    pred_Cb = Block(Cb_region_to_predict)
#    pred_Cr = Block(Cb_region_to_predict)
#    if intra == INTRA_4x4:
#      # partition the prediction region into 4x4 subblocks and predict each using the corresponding mode used
#      # for luma
#      Cb_tree = Partition.grid(ref_colocated_Cb, 4)[0]
#      Cr_tree = Partition.grid(ref_colocated_Cr, 4)[0]
#      for Cb,Cr in scan(Cb_tree, Cr_tree):
#        mode = intra_pred_mode_info(Cb)
#        if mode == 0:
#          H264Intra4x4.vertical(pred_Cb[Cb], Cb)
#          H264Intra4x4.vertical(pred_Cr[Cr], Cr)
#        elif mode == 1:
#          H264Intra4x4.horizontal(pred_Cb[Cb], Cb)
#          H264Intra4x4.horizontal(pred_Cr[Cr], Cr)          
#        elif mode == 2:
#          H264Intra4x4.DC_a(pred_Cb[Cb], Cb)
#          H264Intra4x4.DC_a(pred_Cr[Cr], Cr)
#        elif mode == 3:
#          H264Intra4x4.DC_b(pred_Cb[Cb], Cb)
#          H264Intra4x4.DC_b(pred_Cr[Cr], Cr)          
#        elif mode == 4:
#          H264Intra4x4.DC_c(pred_Cb[Cb], Cb)
#          H264Intra4x4.DC_c(pred_Cr[Cr], Cr)          
#        elif mode == 5:
#          H264Intra4x4.DC_d(pred_Cb[Cb], bit_depth_C)
#          H264Intra4x4.DC_d(pred_Cr[Cr], bit_depth_C)
#        elif mode == 6:
#          H264Intra4x4.diag_down_left(pred_Cb[Cb], Cb)
#          H264Intra4x4.diag_down_left(pred_Cr[Cr], Cr)
#        elif mode == 7:
#          H264Intra4x4.diag_down_right(pred_Cb[Cb], Cb)
#          H264Intra4x4.diag_down_right(pred_Cr[Cr], Cr)
#        elif mode == 8:
#          H264Intra4x4.vertical_right(pred_Cb[Cb], Cb)
#          H264Intra4x4.vertical_right(pred_Cr[Cr], Cr)
#        elif mode == 9:
#          H264Intra4x4.horizontal_down(pred_Cb[Cb], Cb)
#          H264Intra4x4.horizontal_down(pred_Cr[Cr], Cr)          
#        elif mode == 10:
#          H264Intra4x4.vertical_left(pred_Cb[Cb], Cb)
#          H264Intra4x4.vertical_left(pred_Cr[Cr], Cr)
#        else:
#          H264Intra4x4.horizontal_up(pred_Cb[Cb], Cb)
#          H264Intra4x4.horizontal_up(pred_Cr[Cr], Cr)
#    elif intra == INTRA_8x8:
#      # partition the prediction region into 8x8 subblocks and predict each using the corresponding mode used
#      # for luma
#      Cb_tree = Partition.grid(ref_colocated_Cb, 8)[0]
#      Cr_tree = Partition.grid(ref_colocated_Cr, 8)[0]
#      for Cb,Cr in scan(Cb_tree, Cr_tree):
#        # first, we need to reference filter
#        left,up_left,up,up_right = H264Intra8x8.check_availability(Cb_region_to_predict, ref_colocated_Cb, pred_info, constrained_intra_pred_flag)
#        filt_row_Cb,filt_col_Cb,up_right2 = H264Intra8x8.low_pass_filter(Cb, up, left, up_right, up_left)
#        filt_row_Cr,filt_col_Cr,up_right2 = H264Intra8x8.low_pass_filter(Cr, up, left, up_right, up_left)
#        up_right = up_right2
#        mode = intra_pred_mode_info(Cb)
#        if mode == 0:
#          H264Intra8x8.vertical(pred_Cb[Cb], filt_row_Cb)
#          H264Intra8x8.vertical(pred_Cr[Cr], filt_row_Cr)
#        elif mode == 1:
#          H264Intra8x8.horizontal(pred_Cb[Cb], filt_col_Cb)
#          H264Intra8x8.horizontal(pred_Cr[Cr], filt_col_Cr)
#        elif mode == 2:
#          H264Intra8x8.DC_a(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
#          H264Intra8x8.DC_a(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
#        elif mode == 3:
#          H264Intra8x8.DC_b(pred_Cb[Cb], filt_col_Cb)
#          H264Intra8x8.DC_b(pred_Cr[Cr], filt_col_Cr)
#        elif mode == 4:
#          H264Intra8x8.DC_c(pred_Cb[Cb], filt_row_Cb)
#          H264Intra8x8.DC_c(pred_Cr[Cr], filt_row_Cr)
#        elif mode == 5:
#          H264Intra8x8.DC_d(pred_Cb[Cb], bit_depth_C)
#          H264Intra8x8.DC_d(pred_Cr[Cr], bit_depth_C)
#        elif mode == 6:
#          H264Intra8x8.diag_down_left(pred_Cb[Cb], filt_row_Cb)
#          H264Intra8x8.diag_down_left(pred_Cr[Cr], filt_row_Cr)
#        elif mode == 7:
#          H264Intra8x8.diag_down_right(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
#          H264Intra8x8.diag_down_right(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
#        elif mode == 8:
#          H264Intra8x8.vertical_right(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
#          H264Intra8x8.vertical_right(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
#        elif mode == 9:
#          H264Intra8x8.horizontal_down(pred_Cb[Cb], filt_row_Cb, filt_col_Cb)
#          H264Intra8x8.horizontal_down(pred_Cr[Cr], filt_row_Cr, filt_col_Cr)
#        elif mode == 10:
#          H264Intra8x8.vertical_left(pred_Cb[Cb], filt_row_Cb)
#          H264Intra8x8.vertical_left(pred_Cr[Cr], filt_col_Cr)
#        else:
#          H264Intra8x8.horizontal_up(pred_Cb[Cb], filt_col_Cb)
#          H264Intra8x8.horizontal_up(pred_Cr[Cr], filt_col_Cr)
#    else:
#      mode = intra_pred_mode_info(ref_colocated_Cb)
#      if mode == 0:
#        H264Intra16x16.vertical(pred_Cb, ref_colocated_Cb)
#        H264Intra16x16.vertical(pred_Cr, ref_colocated_Cr)
#      elif mode == 1:
#        H264Intra16x16.horizontal(pred_Cb, ref_colocated_Cb)
#        H264Intra16x16.horizontal(pred_Cr, ref_colocated_Cr)    
#      elif mode == 2:
#        H264Intra16x16.DC_a(pred_Cb, ref_colocated_Cb)
#        H264Intra16x16.DC_a(pred_Cr, ref_colocated_Cr)
#      elif mode == 3:
#        H264Intra16x16.DC_b(pred_Cb, ref_colocated_Cb)
#        H264Intra16x16.DC_b(pred_Cr, ref_colocated_Cr)
#      elif mode == 4:
#        H264Intra16x16.DC_c(pred_Cb, ref_colocated_Cb)
#        H264Intra16x16.DC_c(pred_Cr, ref_colocated_Cr)
#      elif mode == 5:
#        H264Intra16x16.DC_d(pred_Cb, bit_depth_C)
#        H264Intra16x16.DC_d(pred_Cr, bit_depth_C)
#      elif mode == 6:
#        H264Intra16x16.DC_d(pred_Cb, ref_colocated_Cb, bit_depth_C)
#        H264Intra16x16.DC_d(pred_Cr, ref_colocated_Cr, bit_depth_C)    
#    return pred_Cb, pred_Cr       
#
